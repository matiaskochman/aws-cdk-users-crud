/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/README.md

# Welcome to your CDK TypeScript project

This is a blank project for CDK development with TypeScript.

The `cdk.json` file tells the CDK Toolkit how to execute your app.

## Useful commands

- `npm run build` compile typescript to js
- `npm run watch` watch for changes and compile
- `npm run test` perform the jest unit tests
- `npx cdk deploy` deploy this stack to your default AWS account/region
- `npx cdk diff` compare deployed stack with current state
- `npx cdk synth` emits the synthesized CloudFormation template

Outputs:
AwsBackendUsersStack.UsersApiEndpointB5FC4B1D = https://mhbdgzoej1.execute-api.us-east-1.amazonaws.com/prod/
Stack ARN:
arn:aws:cloudformation:us-east-1:122610496028:stack/AwsBackendUsersStack/d8065ea0-e0a0-11ef-b0e9-12c72063c265


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/bin/aws-backend-users.d.ts

#!/usr/bin/env node
export {};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/bin/aws-backend-users.js

#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cdk = require("aws-cdk-lib");
const aws_backend_users_stack_1 = require("../lib/aws-backend-users-stack");
const app = new cdk.App();
new aws_backend_users_stack_1.AwsBackendUsersStack(app, "AwsBackendUsersStack");

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/bin/aws-backend-users.ts

#!/usr/bin/env node
import * as cdk from "aws-cdk-lib";
import { AwsBackendUsersStack } from "../lib/aws-backend-users-stack";

const app = new cdk.App();
new AwsBackendUsersStack(app, "AwsBackendUsersStack");


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/cdk.json

{
  "app": "npx ts-node --prefer-ts-exts bin/aws-backend-users.ts",
  "watch": {
    "include": [
      "**"
    ],
    "exclude": [
      "README.md",
      "cdk*.json",
      "**/*.d.ts",
      "**/*.js",
      "tsconfig.json",
      "package*.json",
      "yarn.lock",
      "node_modules",
      "test"
    ]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": [
      "aws",
      "aws-cn"
    ],
    "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
    "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
    "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
    "@aws-cdk/aws-iam:minimizePolicies": true,
    "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
    "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
    "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
    "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
    "@aws-cdk/core:enablePartitionLiterals": true,
    "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
    "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
    "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
    "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
    "@aws-cdk/aws-route53-patters:useCertificate": true,
    "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
    "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
    "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
    "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
    "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
    "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
    "@aws-cdk/aws-redshift:columnId": true,
    "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
    "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
    "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
    "@aws-cdk/aws-kms:aliasNameRef": true,
    "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
    "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
    "@aws-cdk/aws-efs:denyAnonymousAccess": true,
    "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
    "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
    "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
    "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
    "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
    "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
    "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
    "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
    "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
    "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
    "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
    "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
    "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
    "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false,
    "@aws-cdk/aws-s3:keepNotificationInImportedBucket": false,
    "@aws-cdk/aws-ecs:enableImdsBlockingDeprecatedFeature": false,
    "@aws-cdk/aws-ecs:disableEcsImdsBlocking": true,
    "@aws-cdk/aws-ecs:reduceEc2FargateCloudWatchPermissions": true,
    "@aws-cdk/aws-dynamodb:resourcePolicyPerReplica": true,
    "@aws-cdk/aws-ec2:ec2SumTImeoutEnabled": true,
    "@aws-cdk/aws-appsync:appSyncGraphQLAPIScopeLambdaPermission": true,
    "@aws-cdk/aws-rds:setCorrectValueForDatabaseInstanceReadReplicaInstanceResourceId": true,
    "@aws-cdk/core:cfnIncludeRejectComplexResourceUpdateCreatePolicyIntrinsics": true,
    "@aws-cdk/aws-lambda-nodejs:sdkV3ExcludeSmithyPackages": true,
    "@aws-cdk/aws-stepfunctions-tasks:fixRunEcsTaskPolicy": true,
    "@aws-cdk/aws-ec2:bastionHostUseAmazonLinux2023ByDefault": true,
    "@aws-cdk/aws-route53-targets:userPoolDomainNameMethodWithoutCustomResource": true,
    "@aws-cdk/aws-elasticloadbalancingV2:albDualstackWithoutPublicIpv4SecurityGroupRulesDefault": true,
    "@aws-cdk/aws-iam:oidcRejectUnauthorizedConnections": true
  }
}


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/jest.config.js

module.exports = {
  testEnvironment: 'node',
  roots: ['<rootDir>/test'],
  testMatch: ['**/*.test.ts'],
  transform: {
    '^.+\\.tsx?$': 'ts-jest'
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/createUser.d.ts

 * Archivo: lambda/createUser.ts
 * Descripción: Crea un usuario en DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/createUser.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        if (!event.body) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requiere el body de la petición" }),
            };
        }
        const data = JSON.parse(event.body);
        const { userId, email, name } = data;
        if (!userId || !email || !name) {
            return {
                statusCode: 400,
                body: JSON.stringify({
                    message: "Faltan campos obligatorios: userId, email, name",
                }),
            };
        }
        const createdAt = new Date().toISOString();
        const command = new client_dynamodb_1.PutItemCommand({
            TableName: USERS_TABLE,
            Item: {
                userId: { S: userId },
                email: { S: email },
                name: { S: name },
                createdAt: { S: createdAt },
            },
        });
        await ddbClient.send(command);
        return {
            statusCode: 201,
            body: JSON.stringify({ userId, email, name, createdAt }),
        };
    }
    catch (error) {
        console.error("Error creando el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/createUser.ts

 * Archivo: lambda/createUser.ts
 * Descripción: Crea un usuario en DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, PutItemCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }
    const data = JSON.parse(event.body);
    const { userId, email, name } = data;
    if (!userId || !email || !name) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          message: "Faltan campos obligatorios: userId, email, name",
        }),
      };
    }

    const createdAt = new Date().toISOString();

    const command = new PutItemCommand({
      TableName: USERS_TABLE,
      Item: {
        userId: { S: userId },
        email: { S: email },
        name: { S: name },
        createdAt: { S: createdAt },
      },
    });

    await ddbClient.send(command);

    return {
      statusCode: 201,
      body: JSON.stringify({ userId, email, name, createdAt }),
    };
  } catch (error) {
    console.error("Error creando el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/deleteUser.d.ts

 * Archivo: lambda/deleteUser.ts
 * Descripción: Elimina un usuario de DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/deleteUser.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const userId = event.pathParameters?.userId;
        if (!userId) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
            };
        }
        const command = new client_dynamodb_1.DeleteItemCommand({
            TableName: USERS_TABLE,
            Key: { userId: { S: userId } },
        });
        await ddbClient.send(command);
        return {
            statusCode: 200,
            body: JSON.stringify({ message: "Usuario eliminado exitosamente" }),
        };
    }
    catch (error) {
        console.error("Error eliminando el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/deleteUser.ts

 * Archivo: lambda/deleteUser.ts
 * Descripción: Elimina un usuario de DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, DeleteItemCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const userId = event.pathParameters?.userId;
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
      };
    }

    const command = new DeleteItemCommand({
      TableName: USERS_TABLE,
      Key: { userId: { S: userId } },
    });

    await ddbClient.send(command);

    return {
      statusCode: 200,
      body: JSON.stringify({ message: "Usuario eliminado exitosamente" }),
    };
  } catch (error) {
    console.error("Error eliminando el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/generateUploadUrl.d.ts

 * Archivo: lambda/generateUploadUrl.ts
 * Descripción: Genera una URL firmada para cargar archivos en S3
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/generateUploadUrl.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_s3_1 = require("@aws-sdk/client-s3");
const s3_request_presigner_1 = require("@aws-sdk/s3-request-presigner");
const s3Client = new client_s3_1.S3Client({});
const BUCKET_NAME = process.env.BUCKET_NAME || "";
const handler = async (event) => {
    try {
        const data = JSON.parse(event.body || "{}");
        const { fileName, fileType } = data;
        if (!fileName || !fileType) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requieren fileName y fileType" }),
            };
        }
        const command = new client_s3_1.PutObjectCommand({
            Bucket: BUCKET_NAME,
            Key: fileName,
            ContentType: fileType,
        });
        const signedUrl = await (0, s3_request_presigner_1.getSignedUrl)(s3Client, command, { expiresIn: 300 });
        return {
            statusCode: 200,
            body: JSON.stringify({ uploadUrl: signedUrl }),
        };
    }
    catch (error) {
        console.error("Error generando la URL firmada: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/generateUploadUrl.ts

 * Archivo: lambda/generateUploadUrl.ts
 * Descripción: Genera una URL firmada para cargar archivos en S3
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

const s3Client = new S3Client({});
const BUCKET_NAME = process.env.BUCKET_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const data = JSON.parse(event.body || "{}");
    const { fileName, fileType } = data;
    if (!fileName || !fileType) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requieren fileName y fileType" }),
      };
    }

    const command = new PutObjectCommand({
      Bucket: BUCKET_NAME,
      Key: fileName,
      ContentType: fileType,
    });

    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 300 });

    return {
      statusCode: 200,
      body: JSON.stringify({ uploadUrl: signedUrl }),
    };
  } catch (error) {
    console.error("Error generando la URL firmada: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/getUser.d.ts

 * Archivo: lambda/getUser.ts
 * Descripción: Obtiene un usuario por ID desde DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/getUser.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const userId = event.pathParameters?.userId;
        if (!userId) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
            };
        }
        const command = new client_dynamodb_1.GetItemCommand({
            TableName: USERS_TABLE,
            Key: { userId: { S: userId } },
        });
        const response = await ddbClient.send(command);
        if (!response.Item) {
            return {
                statusCode: 404,
                body: JSON.stringify({ message: "Usuario no encontrado" }),
            };
        }
        const user = {
            userId: response.Item.userId.S,
            email: response.Item.email.S,
            name: response.Item.name.S,
            createdAt: response.Item.createdAt.S,
        };
        return {
            statusCode: 200,
            body: JSON.stringify(user),
        };
    }
    catch (error) {
        console.error("Error obteniendo el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/getUser.ts

 * Archivo: lambda/getUser.ts
 * Descripción: Obtiene un usuario por ID desde DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, GetItemCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const userId = event.pathParameters?.userId;
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
      };
    }

    const command = new GetItemCommand({
      TableName: USERS_TABLE,
      Key: { userId: { S: userId } },
    });

    const response = await ddbClient.send(command);

    if (!response.Item) {
      return {
        statusCode: 404,
        body: JSON.stringify({ message: "Usuario no encontrado" }),
      };
    }

    const user = {
      userId: response.Item.userId.S,
      email: response.Item.email.S,
      name: response.Item.name.S,
      createdAt: response.Item.createdAt.S,
    };

    return {
      statusCode: 200,
      body: JSON.stringify(user),
    };
  } catch (error) {
    console.error("Error obteniendo el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/listUsers.d.ts

 * Archivo: lambda/listUsers.ts
 * Descripción: Lista todos los usuarios desde DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/listUsers.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const command = new client_dynamodb_1.ScanCommand({ TableName: USERS_TABLE });
        const response = await ddbClient.send(command);
        const users = response.Items?.map((item) => ({
            userId: item.userId.S,
            email: item.email.S,
            name: item.name.S,
            createdAt: item.createdAt.S,
        })) || [];
        return {
            statusCode: 200,
            body: JSON.stringify(users),
        };
    }
    catch (error) {
        console.error("Error listando usuarios: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/listUsers.ts

 * Archivo: lambda/listUsers.ts
 * Descripción: Lista todos los usuarios desde DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, ScanCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const command = new ScanCommand({ TableName: USERS_TABLE });
    const response = await ddbClient.send(command);
    const users =
      response.Items?.map((item) => ({
        userId: item.userId.S,
        email: item.email.S,
        name: item.name.S,
        createdAt: item.createdAt.S,
      })) || [];

    return {
      statusCode: 200,
      body: JSON.stringify(users),
    };
  } catch (error) {
    console.error("Error listando usuarios: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/updateUser.d.ts

 * Archivo: lambda/updateUser.ts
 * Descripción: Actualiza la información de un usuario en DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/updateUser.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const userId = event.pathParameters?.userId;
        if (!userId) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
            };
        }
        if (!event.body) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requiere el body de la petición" }),
            };
        }
        const data = JSON.parse(event.body);
        const { name, email } = data;
        if (!name && !email) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Nada que actualizar" }),
            };
        }
        let updateExpression = "set";
        const ExpressionAttributeNames = {};
        const ExpressionAttributeValues = {};
        if (name) {
            updateExpression += " #name = :name,";
            ExpressionAttributeNames["#name"] = "name";
            ExpressionAttributeValues[":name"] = { S: name };
        }
        if (email) {
            updateExpression += " email = :email,";
            ExpressionAttributeValues[":email"] = { S: email };
        }
        updateExpression = updateExpression.slice(0, -1); // Eliminar la última coma
        const command = new client_dynamodb_1.UpdateItemCommand({
            TableName: USERS_TABLE,
            Key: { userId: { S: userId } },
            UpdateExpression: updateExpression,
            ExpressionAttributeNames,
            ExpressionAttributeValues,
            ReturnValues: "ALL_NEW",
        });
        const response = await ddbClient.send(command);
        return {
            statusCode: 200,
            body: JSON.stringify(response.Attributes),
        };
    }
    catch (error) {
        console.error("Error actualizando el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/updateUser.ts

 * Archivo: lambda/updateUser.ts
 * Descripción: Actualiza la información de un usuario en DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, UpdateItemCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const userId = event.pathParameters?.userId;
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
      };
    }
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }

    const data = JSON.parse(event.body);
    const { name, email } = data;
    if (!name && !email) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Nada que actualizar" }),
      };
    }

    let updateExpression = "set";
    const ExpressionAttributeNames: Record<string, string> = {};
    const ExpressionAttributeValues: Record<string, any> = {};

    if (name) {
      updateExpression += " #name = :name,";
      ExpressionAttributeNames["#name"] = "name";
      ExpressionAttributeValues[":name"] = { S: name };
    }
    if (email) {
      updateExpression += " email = :email,";
      ExpressionAttributeValues[":email"] = { S: email };
    }
    updateExpression = updateExpression.slice(0, -1); // Eliminar la última coma

    const command = new UpdateItemCommand({
      TableName: USERS_TABLE,
      Key: { userId: { S: userId } },
      UpdateExpression: updateExpression,
      ExpressionAttributeNames,
      ExpressionAttributeValues,
      ReturnValues: "ALL_NEW",
    });

    const response = await ddbClient.send(command);

    return {
      statusCode: 200,
      body: JSON.stringify(response.Attributes),
    };
  } catch (error) {
    console.error("Error actualizando el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lib/aws-backend-users-stack.d.ts

import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
export declare class AwsBackendUsersStack extends cdk.Stack {
    constructor(scope: Construct, id: string, props?: cdk.StackProps);
}


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lib/aws-backend-users-stack.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsBackendUsersStack = void 0;
const cdk = require("aws-cdk-lib");
const dynamodb = require("aws-cdk-lib/aws-dynamodb");
const s3 = require("aws-cdk-lib/aws-s3");
const lambda = require("aws-cdk-lib/aws-lambda");
const lambdaNodejs = require("aws-cdk-lib/aws-lambda-nodejs");
const apigateway = require("aws-cdk-lib/aws-apigateway");
const path = require("path");
class AwsBackendUsersStack extends cdk.Stack {
    constructor(scope, id, props) {
        super(scope, id, props);
        const usersTable = new dynamodb.Table(this, "UsersTable", {
            tableName: "Users",
            partitionKey: { name: "userId", type: dynamodb.AttributeType.STRING },
            billingMode: dynamodb.BillingMode.PROVISIONED,
            removalPolicy: cdk.RemovalPolicy.DESTROY, // Ajusta según el entorno
        });
        usersTable.addGlobalSecondaryIndex({
            indexName: "EmailIndex",
            partitionKey: { name: "email", type: dynamodb.AttributeType.STRING },
            projectionType: dynamodb.ProjectionType.ALL,
        });
        const readScaling = usersTable.autoScaleReadCapacity({
            minCapacity: 5,
            maxCapacity: 50,
        });
        readScaling.scaleOnUtilization({
            targetUtilizationPercent: 70,
        });
        const writeScaling = usersTable.autoScaleWriteCapacity({
            minCapacity: 5,
            maxCapacity: 50,
        });
        writeScaling.scaleOnUtilization({
            targetUtilizationPercent: 70,
        });
        const userUploadsBucket = new s3.Bucket(this, "UserUploadsBucket", {
            bucketName: "user-uploads-cdk-v1",
            versioned: true,
            blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
            removalPolicy: cdk.RemovalPolicy.DESTROY, // Solo para testing; ajustar en producción
            autoDeleteObjects: true, // Para ambientes de prueba
        });
        const createUserLambda = new lambdaNodejs.NodejsFunction(this, "CreateUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/createUser.ts"),
            handler: "handler",
            environment: {
                USERS_TABLE_NAME: usersTable.tableName,
                BUCKET_NAME: userUploadsBucket.bucketName,
            },
        });
        usersTable.grantWriteData(createUserLambda);
        userUploadsBucket.grantPut(createUserLambda);
        const getUserLambda = new lambdaNodejs.NodejsFunction(this, "GetUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/getUser.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantReadData(getUserLambda);
        const listUsersLambda = new lambdaNodejs.NodejsFunction(this, "ListUsersFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/listUsers.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantReadData(listUsersLambda);
        const updateUserLambda = new lambdaNodejs.NodejsFunction(this, "UpdateUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/updateUser.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantReadWriteData(updateUserLambda);
        const deleteUserLambda = new lambdaNodejs.NodejsFunction(this, "DeleteUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/deleteUser.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantWriteData(deleteUserLambda);
        const generateUploadUrlLambda = new lambdaNodejs.NodejsFunction(this, "GenerateUploadUrlFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/generateUploadUrl.ts"),
            handler: "handler",
            environment: { BUCKET_NAME: userUploadsBucket.bucketName },
        });
        userUploadsBucket.grantPut(generateUploadUrlLambda);
        userUploadsBucket.grantRead(generateUploadUrlLambda);
        const api = new apigateway.RestApi(this, "UsersApi", {
            restApiName: "Users Service",
            defaultCorsPreflightOptions: {
                allowOrigins: apigateway.Cors.ALL_ORIGINS,
                allowMethods: apigateway.Cors.ALL_METHODS,
            },
        });
        const usersResource = api.root.addResource("users");
        usersResource.addMethod("POST", new apigateway.LambdaIntegration(createUserLambda));
        usersResource.addMethod("GET", new apigateway.LambdaIntegration(listUsersLambda));
        const userIdResource = usersResource.addResource("{userId}");
        userIdResource.addMethod("GET", new apigateway.LambdaIntegration(getUserLambda));
        userIdResource.addMethod("PUT", new apigateway.LambdaIntegration(updateUserLambda));
        userIdResource.addMethod("DELETE", new apigateway.LambdaIntegration(deleteUserLambda));
        const uploadUrlResource = api.root.addResource("upload-url");
        uploadUrlResource.addMethod("POST", new apigateway.LambdaIntegration(generateUploadUrlLambda));
    }
}
exports.AwsBackendUsersStack = AwsBackendUsersStack;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lib/aws-backend-users-stack.ts


import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
import * as s3 from "aws-cdk-lib/aws-s3";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as lambdaNodejs from "aws-cdk-lib/aws-lambda-nodejs";
import * as apigateway from "aws-cdk-lib/aws-apigateway";
import * as path from "path";

export class AwsBackendUsersStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const usersTable = new dynamodb.Table(this, "UsersTable", {
      tableName: "Users",
      partitionKey: { name: "userId", type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PROVISIONED,
      removalPolicy: cdk.RemovalPolicy.DESTROY, // Ajusta según el entorno
    });

    usersTable.addGlobalSecondaryIndex({
      indexName: "EmailIndex",
      partitionKey: { name: "email", type: dynamodb.AttributeType.STRING },
      projectionType: dynamodb.ProjectionType.ALL,
    });

    const readScaling = usersTable.autoScaleReadCapacity({
      minCapacity: 5,
      maxCapacity: 50,
    });
    readScaling.scaleOnUtilization({
      targetUtilizationPercent: 70,
    });

    const writeScaling = usersTable.autoScaleWriteCapacity({
      minCapacity: 5,
      maxCapacity: 50,
    });
    writeScaling.scaleOnUtilization({
      targetUtilizationPercent: 70,
    });

    const userUploadsBucket = new s3.Bucket(this, "UserUploadsBucket", {
      bucketName: "user-uploads-cdk-v1",
      versioned: true,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
      removalPolicy: cdk.RemovalPolicy.DESTROY, // Solo para testing; ajustar en producción
      autoDeleteObjects: true, // Para ambientes de prueba
    });


    const createUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "CreateUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/createUser.ts"),
        handler: "handler",
        environment: {
          USERS_TABLE_NAME: usersTable.tableName,
          BUCKET_NAME: userUploadsBucket.bucketName,
        },
      }
    );
    usersTable.grantWriteData(createUserLambda);
    userUploadsBucket.grantPut(createUserLambda);

    const getUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "GetUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/getUser.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantReadData(getUserLambda);

    const listUsersLambda = new lambdaNodejs.NodejsFunction(
      this,
      "ListUsersFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/listUsers.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantReadData(listUsersLambda);

    const updateUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "UpdateUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/updateUser.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantReadWriteData(updateUserLambda);

    const deleteUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "DeleteUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/deleteUser.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantWriteData(deleteUserLambda);

    const generateUploadUrlLambda = new lambdaNodejs.NodejsFunction(
      this,
      "GenerateUploadUrlFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/generateUploadUrl.ts"),
        handler: "handler",
        environment: { BUCKET_NAME: userUploadsBucket.bucketName },
      }
    );
    userUploadsBucket.grantPut(generateUploadUrlLambda);
    userUploadsBucket.grantRead(generateUploadUrlLambda);

    const api = new apigateway.RestApi(this, "UsersApi", {
      restApiName: "Users Service",
      defaultCorsPreflightOptions: {
        allowOrigins: apigateway.Cors.ALL_ORIGINS,
        allowMethods: apigateway.Cors.ALL_METHODS,
      },
    });

    const usersResource = api.root.addResource("users");

    usersResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(createUserLambda)
    );
    usersResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(listUsersLambda)
    );

    const userIdResource = usersResource.addResource("{userId}");
    userIdResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(getUserLambda)
    );
    userIdResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(updateUserLambda)
    );
    userIdResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(deleteUserLambda)
    );

    const uploadUrlResource = api.root.addResource("upload-url");
    uploadUrlResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(generateUploadUrlLambda)
    );
  }
}


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/package.json

{
  "name": "aws-backend-users",
  "version": "0.1.0",
  "bin": {
    "aws-backend-users": "bin/aws-backend-users.js"
  },
  "scripts": {
    "build": "tsc",
    "watch": "tsc -w",
    "test": "jest",
    "cdk": "cdk"
  },
  "devDependencies": {
    "@types/aws-lambda": "^8.10.147",
    "@types/jest": "^29.5.14",
    "@types/node": "22.7.9",
    "aws-cdk": "2.177.0",
    "jest": "^29.7.0",
    "source-map-support": "^0.5.21",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "~5.6.3"
  },
  "dependencies": {
    "@aws-cdk/core": "^1.203.0",
    "@aws-sdk/client-dynamodb": "^3.738.0",
    "@aws-sdk/client-s3": "^3.740.0",
    "@aws-sdk/s3-request-presigner": "^3.740.0",
    "aws-cdk-lib": "^2.177.0",
    "constructs": "^10.4.2"
  }
}


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/scripts/output.js

const fs = require("fs");
const path = require("path");

const projectRoot = path.resolve(__dirname, "..");
const outputFilePath = path.join(__dirname, "output.txt");
const fileExtensions = [".ts", ".json", ".js", ".md"];
const excludeDirs = ["node_modules", "cdk.out"];
const excludeFiles = ["package-lock.json"];

function getFiles(dir) {
  let results = [];
  const list = fs.readdirSync(dir);

  list.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat && stat.isDirectory()) {
      if (!excludeDirs.includes(file)) {
        results = results.concat(getFiles(filePath));
      }
    } else if (
      fileExtensions.some((ext) => file.endsWith(ext)) &&
      !excludeFiles.includes(file)
    ) {
      results.push(filePath);
    }
  });

  return results;
}

function removeComments(content, extension) {
  if (extension === ".ts" || extension === ".js") {
    return content
      .split("\n")
      .filter(
        (line) => !line.trim().startsWith("//") && !line.trim().startsWith("/*")
      )
      .join("\n");
  }
  return content; // Para JSON y MD, no eliminamos comentarios
}

const files = getFiles(projectRoot);
let outputContent = "";

files.forEach((file) => {
  try {
    const ext = path.extname(file);
    let content = fs.readFileSync(file, "utf8");
    content = removeComments(content, ext);
    outputContent += `/**************/\n${file}\n\n${content}\n\n`;
  } catch (err) {
    console.error(`Error leyendo el archivo ${file}:`, err);
  }
});

fs.writeFileSync(outputFilePath, outputContent);
console.log(`Archivos copiados a ${outputFilePath}`);


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/test/aws-backend-users.test.d.ts



/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/test/aws-backend-users.test.js

"use strict";
test('SQS Queue Created', () => {
});

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/test/aws-backend-users.test.ts


test('SQS Queue Created', () => {

});


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/tsconfig.json

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": [
      "es2020",
      "dom"
    ],
    "declaration": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": false,
    "inlineSourceMap": true,
    "inlineSources": true,
    "experimentalDecorators": true,
    "strictPropertyInitialization": false,
    "typeRoots": [
      "./node_modules/@types"
    ]
  },
  "exclude": [
    "node_modules",
    "cdk.out"
  ]
}


