/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/README.md

# Welcome to your CDK TypeScript project

This is a blank project for CDK development with TypeScript.

The `cdk.json` file tells the CDK Toolkit how to execute your app.

## Useful commands

- `npm run build` compile typescript to js
- `npm run watch` watch for changes and compile
- `npm run test` perform the jest unit tests
- `npx cdk deploy` deploy this stack to your default AWS account/region
- `npx cdk diff` compare deployed stack with current state
- `npx cdk synth` emits the synthesized CloudFormation template

Outputs:
https://ap3xzldn0c.execute-api.us-east-1.amazonaws.com/prod/

AwsBackendUsersStack.UsersApiEndpointB5FC4B1D = https://mhbdgzoej1.execute-api.us-east-1.amazonaws.com/prod/
Stack ARN:
arn:aws:cloudformation:us-east-1:122610496028:stack/AwsBackendUsersStack/d8065ea0-e0a0-11ef-b0e9-12c72063c265

API_URL="https://ap3xzldn0c.execute-api.us-east-1.amazonaws.com/prod/properties"


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/bin/aws-backend-users.d.ts

#!/usr/bin/env node
export {};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/bin/aws-backend-users.js

#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cdk = require("aws-cdk-lib");
const aws_backend_users_stack_1 = require("../lib/aws-backend-users-stack");
const app = new cdk.App();
new aws_backend_users_stack_1.AwsBackendUsersStack(app, "AwsBackendUsersStack");

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/bin/aws-backend-users.ts

#!/usr/bin/env node
import * as cdk from "aws-cdk-lib";
import { AwsBackendUsersStack } from "../lib/aws-backend-users-stack";

const app = new cdk.App();
new AwsBackendUsersStack(app, "AwsBackendUsersStack");


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/cdk.json

{
  "app": "npx ts-node --prefer-ts-exts bin/aws-backend-users.ts",
  "watch": {
    "include": [
      "**"
    ],
    "exclude": [
      "README.md",
      "cdk*.json",
      "**/*.d.ts",
      "**/*.js",
      "tsconfig.json",
      "package*.json",
      "yarn.lock",
      "node_modules",
      "test"
    ]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": [
      "aws",
      "aws-cn"
    ],
    "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
    "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
    "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
    "@aws-cdk/aws-iam:minimizePolicies": true,
    "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
    "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
    "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
    "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
    "@aws-cdk/core:enablePartitionLiterals": true,
    "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
    "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
    "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
    "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
    "@aws-cdk/aws-route53-patters:useCertificate": true,
    "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
    "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
    "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
    "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
    "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
    "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
    "@aws-cdk/aws-redshift:columnId": true,
    "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
    "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
    "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
    "@aws-cdk/aws-kms:aliasNameRef": true,
    "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
    "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
    "@aws-cdk/aws-efs:denyAnonymousAccess": true,
    "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
    "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
    "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
    "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
    "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
    "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
    "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
    "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
    "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
    "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
    "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
    "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
    "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
    "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false,
    "@aws-cdk/aws-s3:keepNotificationInImportedBucket": false,
    "@aws-cdk/aws-ecs:enableImdsBlockingDeprecatedFeature": false,
    "@aws-cdk/aws-ecs:disableEcsImdsBlocking": true,
    "@aws-cdk/aws-ecs:reduceEc2FargateCloudWatchPermissions": true,
    "@aws-cdk/aws-dynamodb:resourcePolicyPerReplica": true,
    "@aws-cdk/aws-ec2:ec2SumTImeoutEnabled": true,
    "@aws-cdk/aws-appsync:appSyncGraphQLAPIScopeLambdaPermission": true,
    "@aws-cdk/aws-rds:setCorrectValueForDatabaseInstanceReadReplicaInstanceResourceId": true,
    "@aws-cdk/core:cfnIncludeRejectComplexResourceUpdateCreatePolicyIntrinsics": true,
    "@aws-cdk/aws-lambda-nodejs:sdkV3ExcludeSmithyPackages": true,
    "@aws-cdk/aws-stepfunctions-tasks:fixRunEcsTaskPolicy": true,
    "@aws-cdk/aws-ec2:bastionHostUseAmazonLinux2023ByDefault": true,
    "@aws-cdk/aws-route53-targets:userPoolDomainNameMethodWithoutCustomResource": true,
    "@aws-cdk/aws-elasticloadbalancingV2:albDualstackWithoutPublicIpv4SecurityGroupRulesDefault": true,
    "@aws-cdk/aws-iam:oidcRejectUnauthorizedConnections": true
  }
}


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/jest.config.js

module.exports = {
  testEnvironment: 'node',
  roots: ['<rootDir>/test'],
  testMatch: ['**/*.test.ts'],
  transform: {
    '^.+\\.tsx?$': 'ts-jest'
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/createProperty.ts

 * Archivo: lambda/createProperty.ts
 * Descripción: Crea una propiedad en la tabla Properties de DynamoDB.
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, PutItemCommand } from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { Property } from "../../models/Property";

const ddbClient = new DynamoDBClient({});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }
    const data: Property = JSON.parse(event.body);

    if (data.id === undefined || !data.titulo) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          message: "Se requieren los campos 'id' y 'titulo'",
        }),
      };
    }

    data.fechaPublicacion = new Date(data.fechaPublicacion).toISOString();

    const item = marshall(data, { removeUndefinedValues: true });

    const command = new PutItemCommand({
      TableName: PROPERTIES_TABLE,
      Item: item,
    });
    await ddbClient.send(command);

    return {
      statusCode: 201,
      body: JSON.stringify(data),
    };
  } catch (error) {
    console.error("Error creando la propiedad: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/deleteProperty.ts

 * Archivo: lambda/deleteProperty.ts
 * Descripción: Elimina una propiedad de la tabla Properties en DynamoDB.
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, DeleteItemCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const idParam = event.pathParameters?.id;
    if (!idParam) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
      };
    }
    const id = Number(idParam);
    if (isNaN(id)) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El id debe ser un número" }),
      };
    }

    const command = new DeleteItemCommand({
      TableName: PROPERTIES_TABLE,
      Key: {
        id: { N: id.toString() },
      },
    });
    await ddbClient.send(command);

    return {
      statusCode: 200,
      body: JSON.stringify({ message: "Propiedad eliminada exitosamente" }),
    };
  } catch (error) {
    console.error("Error eliminando la propiedad: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/getProperty.ts

 * Archivo: lambda/getProperty.ts
 * Descripción: Obtiene una propiedad por id desde la tabla Properties en DynamoDB.
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, GetItemCommand } from "@aws-sdk/client-dynamodb";
import { unmarshall } from "@aws-sdk/util-dynamodb";
import { Property } from "../../models/Property";

const ddbClient = new DynamoDBClient({});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const idParam = event.pathParameters?.id;
    if (!idParam) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
      };
    }
    const id = Number(idParam);
    if (isNaN(id)) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El id debe ser un número" }),
      };
    }

    const command = new GetItemCommand({
      TableName: PROPERTIES_TABLE,
      Key: {
        id: { N: id.toString() },
      },
    });

    const response = await ddbClient.send(command);
    if (!response.Item) {
      return {
        statusCode: 404,
        body: JSON.stringify({ message: "Propiedad no encontrada" }),
      };
    }

    const property = unmarshall(response.Item) as Property;
    return {
      statusCode: 200,
      body: JSON.stringify(property),
    };
  } catch (error) {
    console.error("Error obteniendo la propiedad: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/listProperties.ts

 * Archivo: lambda/listProperties.ts
 * Descripción: Lista todas las propiedades de la tabla Properties en DynamoDB.
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, ScanCommand } from "@aws-sdk/client-dynamodb";
import { unmarshall } from "@aws-sdk/util-dynamodb";
import { Property } from "../../models/Property";

const ddbClient = new DynamoDBClient({});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const command = new ScanCommand({
      TableName: PROPERTIES_TABLE,
    });
    const response = await ddbClient.send(command);
    const properties =
      response.Items?.map((item) => unmarshall(item) as Property) || [];

    return {
      statusCode: 200,
      body: JSON.stringify(properties),
    };
  } catch (error) {
    console.error("Error listando propiedades: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/updateProperty.ts

 * Archivo: lambda/updateProperty.ts
 * Descripción: Actualiza (reemplaza) una propiedad en la tabla Properties de DynamoDB.
 * Se utiliza un reemplazo completo mediante PutItemCommand.
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, PutItemCommand } from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { Property } from "../../models/Property";

const ddbClient = new DynamoDBClient({});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const idParam = event.pathParameters?.id;
    if (!idParam) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
      };
    }
    const id = Number(idParam);
    if (isNaN(id)) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El id debe ser un número" }),
      };
    }
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }

    const data: Property = JSON.parse(event.body);
    if (data.id && Number(data.id) !== id) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          message: "El id del body debe coincidir con el id de la URL",
        }),
      };
    }
    data.id = id;

    data.fechaPublicacion = new Date(data.fechaPublicacion).toISOString();

    const item = marshall(data, { removeUndefinedValues: true });

    const command = new PutItemCommand({
      TableName: PROPERTIES_TABLE,
      Item: item,
    });
    await ddbClient.send(command);

    return {
      statusCode: 200,
      body: JSON.stringify(data),
    };
  } catch (error) {
    console.error("Error actualizando la propiedad: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/createUser.d.ts

 * Archivo: lambda/createUser.ts
 * Descripción: Crea un usuario en DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/createUser.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        if (!event.body) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requiere el body de la petición" }),
            };
        }
        const data = JSON.parse(event.body);
        const { userId, email, name } = data;
        if (!userId || !email || !name) {
            return {
                statusCode: 400,
                body: JSON.stringify({
                    message: "Faltan campos obligatorios: userId, email, name",
                }),
            };
        }
        const createdAt = new Date().toISOString();
        const command = new client_dynamodb_1.PutItemCommand({
            TableName: USERS_TABLE,
            Item: {
                userId: { S: userId },
                email: { S: email },
                name: { S: name },
                createdAt: { S: createdAt },
            },
        });
        await ddbClient.send(command);
        return {
            statusCode: 201,
            body: JSON.stringify({ userId, email, name, createdAt }),
        };
    }
    catch (error) {
        console.error("Error creando el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/createUser.ts

 * Archivo: lambda/createUser.ts
 * Descripción: Crea un usuario en DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, PutItemCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }
    const data = JSON.parse(event.body);
    const { userId, email, name } = data;
    if (!userId || !email || !name) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          message: "Faltan campos obligatorios: userId, email, name",
        }),
      };
    }

    const createdAt = new Date().toISOString();

    const command = new PutItemCommand({
      TableName: USERS_TABLE,
      Item: {
        userId: { S: userId },
        email: { S: email },
        name: { S: name },
        createdAt: { S: createdAt },
      },
    });

    await ddbClient.send(command);

    return {
      statusCode: 201,
      body: JSON.stringify({ userId, email, name, createdAt }),
    };
  } catch (error) {
    console.error("Error creando el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/deleteUser.d.ts

 * Archivo: lambda/deleteUser.ts
 * Descripción: Elimina un usuario de DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/deleteUser.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const userId = event.pathParameters?.userId;
        if (!userId) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
            };
        }
        const command = new client_dynamodb_1.DeleteItemCommand({
            TableName: USERS_TABLE,
            Key: { userId: { S: userId } },
        });
        await ddbClient.send(command);
        return {
            statusCode: 200,
            body: JSON.stringify({ message: "Usuario eliminado exitosamente" }),
        };
    }
    catch (error) {
        console.error("Error eliminando el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/deleteUser.ts

 * Archivo: lambda/deleteUser.ts
 * Descripción: Elimina un usuario de DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, DeleteItemCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const userId = event.pathParameters?.userId;
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
      };
    }

    const command = new DeleteItemCommand({
      TableName: USERS_TABLE,
      Key: { userId: { S: userId } },
    });

    await ddbClient.send(command);

    return {
      statusCode: 200,
      body: JSON.stringify({ message: "Usuario eliminado exitosamente" }),
    };
  } catch (error) {
    console.error("Error eliminando el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/generateUploadUrl.d.ts

 * Archivo: lambda/generateUploadUrl.ts
 * Descripción: Genera una URL firmada para cargar archivos en S3
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/generateUploadUrl.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_s3_1 = require("@aws-sdk/client-s3");
const s3_request_presigner_1 = require("@aws-sdk/s3-request-presigner");
const s3Client = new client_s3_1.S3Client({});
const BUCKET_NAME = process.env.BUCKET_NAME || "";
const handler = async (event) => {
    try {
        const data = JSON.parse(event.body || "{}");
        const { fileName, fileType } = data;
        if (!fileName || !fileType) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requieren fileName y fileType" }),
            };
        }
        const command = new client_s3_1.PutObjectCommand({
            Bucket: BUCKET_NAME,
            Key: fileName,
            ContentType: fileType,
        });
        const signedUrl = await (0, s3_request_presigner_1.getSignedUrl)(s3Client, command, { expiresIn: 300 });
        return {
            statusCode: 200,
            body: JSON.stringify({ uploadUrl: signedUrl }),
        };
    }
    catch (error) {
        console.error("Error generando la URL firmada: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/generateUploadUrl.ts

 * Archivo: lambda/generateUploadUrl.ts
 * Descripción: Genera una URL firmada para cargar archivos en S3
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

const s3Client = new S3Client({});
const BUCKET_NAME = process.env.BUCKET_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const data = JSON.parse(event.body || "{}");
    const { fileName, fileType } = data;
    if (!fileName || !fileType) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requieren fileName y fileType" }),
      };
    }

    const command = new PutObjectCommand({
      Bucket: BUCKET_NAME,
      Key: fileName,
      ContentType: fileType,
    });

    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 300 });

    return {
      statusCode: 200,
      body: JSON.stringify({ uploadUrl: signedUrl }),
    };
  } catch (error) {
    console.error("Error generando la URL firmada: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/getUser.d.ts

 * Archivo: lambda/getUser.ts
 * Descripción: Obtiene un usuario por ID desde DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/getUser.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const userId = event.pathParameters?.userId;
        if (!userId) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
            };
        }
        const command = new client_dynamodb_1.GetItemCommand({
            TableName: USERS_TABLE,
            Key: { userId: { S: userId } },
        });
        const response = await ddbClient.send(command);
        if (!response.Item) {
            return {
                statusCode: 404,
                body: JSON.stringify({ message: "Usuario no encontrado" }),
            };
        }
        const user = {
            userId: response.Item.userId.S,
            email: response.Item.email.S,
            name: response.Item.name.S,
            createdAt: response.Item.createdAt.S,
        };
        return {
            statusCode: 200,
            body: JSON.stringify(user),
        };
    }
    catch (error) {
        console.error("Error obteniendo el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/getUser.ts

 * Archivo: lambda/getUser.ts
 * Descripción: Obtiene un usuario por ID desde DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, GetItemCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const userId = event.pathParameters?.userId;
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
      };
    }

    const command = new GetItemCommand({
      TableName: USERS_TABLE,
      Key: { userId: { S: userId } },
    });

    const response = await ddbClient.send(command);

    if (!response.Item) {
      return {
        statusCode: 404,
        body: JSON.stringify({ message: "Usuario no encontrado" }),
      };
    }

    const user = {
      userId: response.Item.userId.S,
      email: response.Item.email.S,
      name: response.Item.name.S,
      createdAt: response.Item.createdAt.S,
    };

    return {
      statusCode: 200,
      body: JSON.stringify(user),
    };
  } catch (error) {
    console.error("Error obteniendo el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/listUsers.d.ts

 * Archivo: lambda/listUsers.ts
 * Descripción: Lista todos los usuarios desde DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/listUsers.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const command = new client_dynamodb_1.ScanCommand({ TableName: USERS_TABLE });
        const response = await ddbClient.send(command);
        const users = response.Items?.map((item) => ({
            userId: item.userId.S,
            email: item.email.S,
            name: item.name.S,
            createdAt: item.createdAt.S,
        })) || [];
        return {
            statusCode: 200,
            body: JSON.stringify(users),
        };
    }
    catch (error) {
        console.error("Error listando usuarios: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/listUsers.ts

 * Archivo: lambda/listUsers.ts
 * Descripción: Lista todos los usuarios desde DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, ScanCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const command = new ScanCommand({ TableName: USERS_TABLE });
    const response = await ddbClient.send(command);
    const users =
      response.Items?.map((item) => ({
        userId: item.userId.S,
        email: item.email.S,
        name: item.name.S,
        createdAt: item.createdAt.S,
      })) || [];

    return {
      statusCode: 200,
      body: JSON.stringify(users),
    };
  } catch (error) {
    console.error("Error listando usuarios: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/updateUser.d.ts

 * Archivo: lambda/updateUser.ts
 * Descripción: Actualiza la información de un usuario en DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
export declare const handler: (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/updateUser.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const ddbClient = new client_dynamodb_1.DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const userId = event.pathParameters?.userId;
        if (!userId) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
            };
        }
        if (!event.body) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requiere el body de la petición" }),
            };
        }
        const data = JSON.parse(event.body);
        const { name, email } = data;
        if (!name && !email) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Nada que actualizar" }),
            };
        }
        let updateExpression = "set";
        const ExpressionAttributeNames = {};
        const ExpressionAttributeValues = {};
        if (name) {
            updateExpression += " #name = :name,";
            ExpressionAttributeNames["#name"] = "name";
            ExpressionAttributeValues[":name"] = { S: name };
        }
        if (email) {
            updateExpression += " email = :email,";
            ExpressionAttributeValues[":email"] = { S: email };
        }
        updateExpression = updateExpression.slice(0, -1); // Eliminar la última coma
        const command = new client_dynamodb_1.UpdateItemCommand({
            TableName: USERS_TABLE,
            Key: { userId: { S: userId } },
            UpdateExpression: updateExpression,
            ExpressionAttributeNames,
            ExpressionAttributeValues,
            ReturnValues: "ALL_NEW",
        });
        const response = await ddbClient.send(command);
        return {
            statusCode: 200,
            body: JSON.stringify(response.Attributes),
        };
    }
    catch (error) {
        console.error("Error actualizando el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/updateUser.ts

 * Archivo: lambda/updateUser.ts
 * Descripción: Actualiza la información de un usuario en DynamoDB
 */
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, UpdateItemCommand } from "@aws-sdk/client-dynamodb";

const ddbClient = new DynamoDBClient({});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";

export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const userId = event.pathParameters?.userId;
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
      };
    }
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }

    const data = JSON.parse(event.body);
    const { name, email } = data;
    if (!name && !email) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Nada que actualizar" }),
      };
    }

    let updateExpression = "set";
    const ExpressionAttributeNames: Record<string, string> = {};
    const ExpressionAttributeValues: Record<string, any> = {};

    if (name) {
      updateExpression += " #name = :name,";
      ExpressionAttributeNames["#name"] = "name";
      ExpressionAttributeValues[":name"] = { S: name };
    }
    if (email) {
      updateExpression += " email = :email,";
      ExpressionAttributeValues[":email"] = { S: email };
    }
    updateExpression = updateExpression.slice(0, -1); // Eliminar la última coma

    const command = new UpdateItemCommand({
      TableName: USERS_TABLE,
      Key: { userId: { S: userId } },
      UpdateExpression: updateExpression,
      ExpressionAttributeNames,
      ExpressionAttributeValues,
      ReturnValues: "ALL_NEW",
    });

    const response = await ddbClient.send(command);

    return {
      statusCode: 200,
      body: JSON.stringify(response.Attributes),
    };
  } catch (error) {
    console.error("Error actualizando el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lib/aws-backend-users-stack.d.ts

import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
export declare class AwsBackendUsersStack extends cdk.Stack {
    constructor(scope: Construct, id: string, props?: cdk.StackProps);
}


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lib/aws-backend-users-stack.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsBackendUsersStack = void 0;
const cdk = require("aws-cdk-lib");
const dynamodb = require("aws-cdk-lib/aws-dynamodb");
const s3 = require("aws-cdk-lib/aws-s3");
const lambda = require("aws-cdk-lib/aws-lambda");
const lambdaNodejs = require("aws-cdk-lib/aws-lambda-nodejs");
const apigateway = require("aws-cdk-lib/aws-apigateway");
const path = require("path");
class AwsBackendUsersStack extends cdk.Stack {
    constructor(scope, id, props) {
        super(scope, id, props);
        const usersTable = new dynamodb.Table(this, "UsersTable", {
            tableName: "Users",
            partitionKey: { name: "userId", type: dynamodb.AttributeType.STRING },
            billingMode: dynamodb.BillingMode.PROVISIONED,
            removalPolicy: cdk.RemovalPolicy.DESTROY, // Ajusta según el entorno
        });
        usersTable.addGlobalSecondaryIndex({
            indexName: "EmailIndex",
            partitionKey: { name: "email", type: dynamodb.AttributeType.STRING },
            projectionType: dynamodb.ProjectionType.ALL,
        });
        const readScaling = usersTable.autoScaleReadCapacity({
            minCapacity: 5,
            maxCapacity: 50,
        });
        readScaling.scaleOnUtilization({
            targetUtilizationPercent: 70,
        });
        const writeScaling = usersTable.autoScaleWriteCapacity({
            minCapacity: 5,
            maxCapacity: 50,
        });
        writeScaling.scaleOnUtilization({
            targetUtilizationPercent: 70,
        });
        const userUploadsBucket = new s3.Bucket(this, "UserUploadsBucket", {
            bucketName: "user-uploads-cdk-v1",
            versioned: true,
            blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
            removalPolicy: cdk.RemovalPolicy.DESTROY, // Solo para testing; ajustar en producción
            autoDeleteObjects: true, // Para ambientes de prueba
        });
        const createUserLambda = new lambdaNodejs.NodejsFunction(this, "CreateUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/createUser.ts"),
            handler: "handler",
            environment: {
                USERS_TABLE_NAME: usersTable.tableName,
                BUCKET_NAME: userUploadsBucket.bucketName,
            },
        });
        usersTable.grantWriteData(createUserLambda);
        userUploadsBucket.grantPut(createUserLambda);
        const getUserLambda = new lambdaNodejs.NodejsFunction(this, "GetUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/getUser.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantReadData(getUserLambda);
        const listUsersLambda = new lambdaNodejs.NodejsFunction(this, "ListUsersFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/listUsers.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantReadData(listUsersLambda);
        const updateUserLambda = new lambdaNodejs.NodejsFunction(this, "UpdateUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/updateUser.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantReadWriteData(updateUserLambda);
        const deleteUserLambda = new lambdaNodejs.NodejsFunction(this, "DeleteUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/deleteUser.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantWriteData(deleteUserLambda);
        const generateUploadUrlLambda = new lambdaNodejs.NodejsFunction(this, "GenerateUploadUrlFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/generateUploadUrl.ts"),
            handler: "handler",
            environment: { BUCKET_NAME: userUploadsBucket.bucketName },
        });
        userUploadsBucket.grantPut(generateUploadUrlLambda);
        userUploadsBucket.grantRead(generateUploadUrlLambda);
        const api = new apigateway.RestApi(this, "UsersApi", {
            restApiName: "Users Service",
            defaultCorsPreflightOptions: {
                allowOrigins: apigateway.Cors.ALL_ORIGINS,
                allowMethods: apigateway.Cors.ALL_METHODS,
            },
        });
        const usersResource = api.root.addResource("users");
        usersResource.addMethod("POST", new apigateway.LambdaIntegration(createUserLambda));
        usersResource.addMethod("GET", new apigateway.LambdaIntegration(listUsersLambda));
        const userIdResource = usersResource.addResource("{userId}");
        userIdResource.addMethod("GET", new apigateway.LambdaIntegration(getUserLambda));
        userIdResource.addMethod("PUT", new apigateway.LambdaIntegration(updateUserLambda));
        userIdResource.addMethod("DELETE", new apigateway.LambdaIntegration(deleteUserLambda));
        const uploadUrlResource = api.root.addResource("upload-url");
        uploadUrlResource.addMethod("POST", new apigateway.LambdaIntegration(generateUploadUrlLambda));
    }
}
exports.AwsBackendUsersStack = AwsBackendUsersStack;

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/lib/aws-backend-users-stack.ts


import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
import * as s3 from "aws-cdk-lib/aws-s3";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as lambdaNodejs from "aws-cdk-lib/aws-lambda-nodejs";
import * as apigateway from "aws-cdk-lib/aws-apigateway";
import * as path from "path";

export class AwsBackendUsersStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const usersTable = new dynamodb.Table(this, "UsersTable", {
      tableName: "Users",
      partitionKey: { name: "userId", type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PROVISIONED,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    usersTable.addGlobalSecondaryIndex({
      indexName: "EmailIndex",
      partitionKey: { name: "email", type: dynamodb.AttributeType.STRING },
      projectionType: dynamodb.ProjectionType.ALL,
    });

    const readScaling = usersTable.autoScaleReadCapacity({
      minCapacity: 5,
      maxCapacity: 50,
    });
    readScaling.scaleOnUtilization({
      targetUtilizationPercent: 70,
    });

    const writeScaling = usersTable.autoScaleWriteCapacity({
      minCapacity: 5,
      maxCapacity: 50,
    });
    writeScaling.scaleOnUtilization({
      targetUtilizationPercent: 70,
    });

    const userUploadsBucket = new s3.Bucket(this, "UserUploadsBucket", {
      bucketName: "user-uploads-cdk-v1",
      versioned: true,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      autoDeleteObjects: true,
    });

    const propertiesTable = new dynamodb.Table(this, "PropertiesTable", {
      tableName: "Properties",
      partitionKey: { name: "id", type: dynamodb.AttributeType.NUMBER },
      billingMode: dynamodb.BillingMode.PROVISIONED,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    const propertiesReadScaling = propertiesTable.autoScaleReadCapacity({
      minCapacity: 5,
      maxCapacity: 50,
    });
    propertiesReadScaling.scaleOnUtilization({
      targetUtilizationPercent: 70,
    });

    const propertiesWriteScaling = propertiesTable.autoScaleWriteCapacity({
      minCapacity: 5,
      maxCapacity: 50,
    });
    propertiesWriteScaling.scaleOnUtilization({
      targetUtilizationPercent: 70,
    });

    const createUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "CreateUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/createUser.ts"),
        handler: "handler",
        environment: {
          USERS_TABLE_NAME: usersTable.tableName,
          BUCKET_NAME: userUploadsBucket.bucketName,
        },
      }
    );
    usersTable.grantWriteData(createUserLambda);
    userUploadsBucket.grantPut(createUserLambda);

    const getUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "GetUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/getUser.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantReadData(getUserLambda);

    const listUsersLambda = new lambdaNodejs.NodejsFunction(
      this,
      "ListUsersFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/listUsers.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantReadData(listUsersLambda);

    const updateUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "UpdateUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/updateUser.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantReadWriteData(updateUserLambda);

    const deleteUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "DeleteUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/deleteUser.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantWriteData(deleteUserLambda);

    const generateUploadUrlLambda = new lambdaNodejs.NodejsFunction(
      this,
      "GenerateUploadUrlFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/generateUploadUrl.ts"),
        handler: "handler",
        environment: { BUCKET_NAME: userUploadsBucket.bucketName },
      }
    );
    userUploadsBucket.grantPut(generateUploadUrlLambda);
    userUploadsBucket.grantRead(generateUploadUrlLambda);

    const createPropertyLambda = new lambdaNodejs.NodejsFunction(
      this,
      "CreatePropertyFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/createProperty.ts"),
        handler: "handler",
        environment: {
          PROPERTIES_TABLE_NAME: propertiesTable.tableName,
        },
      }
    );
    propertiesTable.grantWriteData(createPropertyLambda);

    const getPropertyLambda = new lambdaNodejs.NodejsFunction(
      this,
      "GetPropertyFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/getProperty.ts"),
        handler: "handler",
        environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
      }
    );
    propertiesTable.grantReadData(getPropertyLambda);

    const listPropertiesLambda = new lambdaNodejs.NodejsFunction(
      this,
      "ListPropertiesFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/listProperties.ts"),
        handler: "handler",
        environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
      }
    );
    propertiesTable.grantReadData(listPropertiesLambda);

    const updatePropertyLambda = new lambdaNodejs.NodejsFunction(
      this,
      "UpdatePropertyFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/updateProperty.ts"),
        handler: "handler",
        environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
      }
    );
    propertiesTable.grantReadWriteData(updatePropertyLambda);

    const deletePropertyLambda = new lambdaNodejs.NodejsFunction(
      this,
      "DeletePropertyFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/deleteProperty.ts"),
        handler: "handler",
        environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
      }
    );
    propertiesTable.grantWriteData(deletePropertyLambda);

    const api = new apigateway.RestApi(this, "UsersAndPropertiesApi", {
      restApiName: "Users & Properties Service",
      defaultCorsPreflightOptions: {
        allowOrigins: apigateway.Cors.ALL_ORIGINS,
        allowMethods: apigateway.Cors.ALL_METHODS,
      },
    });

    const usersResource = api.root.addResource("users");
    usersResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(createUserLambda)
    );
    usersResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(listUsersLambda)
    );

    const userIdResource = usersResource.addResource("{userId}");
    userIdResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(getUserLambda)
    );
    userIdResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(updateUserLambda)
    );
    userIdResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(deleteUserLambda)
    );

    const propertiesResource = api.root.addResource("properties");
    propertiesResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(createPropertyLambda)
    );
    propertiesResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(listPropertiesLambda)
    );

    const propertyIdResource = propertiesResource.addResource("{id}");
    propertyIdResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(getPropertyLambda)
    );
    propertyIdResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(updatePropertyLambda)
    );
    propertyIdResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(deletePropertyLambda)
    );
  }
}


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/models/Property.ts

export interface Property {
  id: number;
  titulo: string;
  ubicacion: {
    direccion: string;
    ciudad: string;
    provincia: string;
    pais: string;
  };
  precio: {
    monto: number;
    moneda: "USD" | "ARS" | "EUR"; // Se pueden agregar más monedas
    periodo: "mensual" | "anual" | "semanal"; // Se pueden agregar más periodos
  };
  tipo: "departamento" | "casa" | "ph" | "terreno"; // Otros tipos de propiedades
  ambientes: number;
  dormitorios: number;
  banos: number;
  superficie: {
    total: number; // en m²
    cubierta: number; // en m²
  };
  amueblado: boolean;
  servicios: string[];
  amenities: string[];
  ocupaciones: [string, string][]; // Rango de fechas ocupadas ["dd-mm-yyyy", "dd-mm-yyyy"]
  fechasNoDisponibles: string[]; // Fechas específicas no disponibles ["dd-mm-yyyy"]
  contacto: {
    nombre: string;
    telefono: string;
    email: string;
  };
  imagenes: string[];
  fechaPublicacion: string; // Formato ISO8601 ("YYYY-MM-DDTHH:MM:SSZ")
  descripcion: string;
}


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/package.json

{
  "name": "aws-backend-users",
  "version": "0.1.0",
  "bin": {
    "aws-backend-users": "bin/aws-backend-users.js"
  },
  "scripts": {
    "build": "tsc",
    "watch": "tsc -w",
    "test": "jest",
    "cdk": "cdk"
  },
  "devDependencies": {
    "@types/aws-lambda": "^8.10.147",
    "@types/jest": "^29.5.14",
    "@types/node": "22.7.9",
    "aws-cdk": "2.177.0",
    "jest": "^29.7.0",
    "source-map-support": "^0.5.21",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "~5.6.3"
  },
  "dependencies": {
    "@aws-cdk/core": "^1.203.0",
    "@aws-sdk/client-dynamodb": "^3.738.0",
    "@aws-sdk/client-s3": "^3.740.0",
    "@aws-sdk/s3-request-presigner": "^3.740.0",
    "@aws-sdk/util-dynamodb": "^3.738.0",
    "aws-cdk-lib": "^2.177.0",
    "constructs": "^10.4.2"
  }
}


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/scripts/curls.sh

API_URL="https://ap3xzldn0c.execute-api.us-east-1.amazonaws.com/prod/properties"


curl -X POST "$API_URL" \
     -H "Content-Type: application/json" \
     -d '{
          "id": 1,
          "titulo": "Departamento en Palermo, Buenos Aires",
          "ubicacion": {
            "direccion": "Av. Santa Fe 3400",
            "ciudad": "Buenos Aires",
            "provincia": "Buenos Aires",
            "pais": "Argentina"
          },
          "precio": {
            "monto": 800,
            "moneda": "USD",
            "periodo": "mensual"
          },
          "tipo": "departamento",
          "ambientes": 3,
          "dormitorios": 2,
          "banos": 1,
          "superficie": {
            "total": 80,
            "cubierta": 70
          },
          "amueblado": true,
          "servicios": ["wifi", "agua", "electricidad", "gas"],
          "amenities": ["pileta", "gimnasio", "terraza", "seguridad 24hs"],
          "ocupaciones": [["01-01-2025", "15-01-2025"]],
          "fechasNoDisponibles": ["25-12-2024"],
          "contacto": {
            "nombre": "Juan Pérez",
            "telefono": "+54 11 1234-5678",
            "email": "juanperez@example.com"
          },
          "imagenes": [
            "https://ejemplo.com/departamento-palermo1.jpg",
            "https://ejemplo.com/departamento-palermo2.jpg"
          ],
          "fechaPublicacion": "2024-02-03T12:00:00Z",
          "descripcion": "Departamento moderno en el corazón de Palermo, ideal para familias o parejas."
        }'


curl -X POST "$API_URL" \
     -H "Content-Type: application/json" \
     -d '{
          "id": 2,
          "titulo": "Casa en Nordelta con jardín y pileta",
          "ubicacion": {
            "direccion": "Calle Los Álamos 123",
            "ciudad": "Tigre",
            "provincia": "Buenos Aires",
            "pais": "Argentina"
          },
          "precio": {
            "monto": 2500,
            "moneda": "USD",
            "periodo": "mensual"
          },
          "tipo": "casa",
          "ambientes": 5,
          "dormitorios": 4,
          "banos": 3,
          "superficie": {
            "total": 300,
            "cubierta": 250
          },
          "amueblado": false,
          "servicios": ["wifi", "agua", "electricidad", "gas", "seguridad"],
          "amenities": ["pileta", "quincho", "cochera doble"],
          "ocupaciones": [],
          "fechasNoDisponibles": ["01-05-2025"],
          "contacto": {
            "nombre": "María Rodríguez",
            "telefono": "+54 11 9876-5432",
            "email": "maria.rodriguez@example.com"
          },
          "imagenes": [
            "https://ejemplo.com/casa-nordelta1.jpg",
            "https://ejemplo.com/casa-nordelta2.jpg"
          ],
          "fechaPublicacion": "2024-02-05T15:00:00Z",
          "descripcion": "Hermosa casa en barrio privado, con vista al lago y excelente seguridad."
        }'


curl -X POST "$API_URL" \
     -H "Content-Type: application/json" \
     -d '{
          "id": 3,
          "titulo": "PH en San Telmo con terraza propia",
          "ubicacion": {
            "direccion": "Defensa 750",
            "ciudad": "Buenos Aires",
            "provincia": "Buenos Aires",
            "pais": "Argentina"
          },
          "precio": {
            "monto": 1200,
            "moneda": "USD",
            "periodo": "mensual"
          },
          "tipo": "ph",
          "ambientes": 4,
          "dormitorios": 2,
          "banos": 2,
          "superficie": {
            "total": 150,
            "cubierta": 100
          },
          "amueblado": true,
          "servicios": ["wifi", "agua", "electricidad", "gas"],
          "amenities": ["terraza", "parrilla"],
          "ocupaciones": [["05-06-2025", "20-06-2025"]],
          "fechasNoDisponibles": [],
          "contacto": {
            "nombre": "Carlos López",
            "telefono": "+54 11 3333-5555",
            "email": "carlos.lopez@example.com"
          },
          "imagenes": [
            "https://ejemplo.com/ph-santelmo1.jpg",
            "https://ejemplo.com/ph-santelmo2.jpg"
          ],
          "fechaPublicacion": "2024-02-06T18:00:00Z",
          "descripcion": "PH con detalles únicos, techos altos y una increíble terraza en el corazón de San Telmo."
        }'


curl -X POST "$API_URL" \
     -H "Content-Type: application/json" \
     -d '{
          "id": 4,
          "titulo": "Terreno en Bariloche con vista al lago",
          "ubicacion": {
            "direccion": "Ruta 40 km 2040",
            "ciudad": "San Carlos de Bariloche",
            "provincia": "Río Negro",
            "pais": "Argentina"
          },
          "precio": {
            "monto": 100000,
            "moneda": "USD",
            "periodo": "único"
          },
          "tipo": "terreno",
          "ambientes": 0,
          "dormitorios": 0,
          "banos": 0,
          "superficie": {
            "total": 5000,
            "cubierta": 0
          },
          "amueblado": false,
          "servicios": ["electricidad", "agua"],
          "amenities": [],
          "ocupaciones": [],
          "fechasNoDisponibles": [],
          "contacto": {
            "nombre": "Luciana Gómez",
            "telefono": "+54 294 456-7890",
            "email": "luciana.gomez@example.com"
          },
          "imagenes": [
            "https://ejemplo.com/terreno-bariloche1.jpg",
            "https://ejemplo.com/terreno-bariloche2.jpg"
          ],
          "fechaPublicacion": "2024-02-07T09:30:00Z",
          "descripcion": "Terreno amplio con vista panorámica al lago Nahuel Huapi, ideal para construir cabañas."
        }'


curl -X POST "$API_URL" \
     -H "Content-Type: application/json" \
     -d '{
          "id": 5,
          "titulo": "Loft en Puerto Madero con vista al río",
          "ubicacion": {
            "direccion": "Av. Alicia Moreau de Justo 2000",
            "ciudad": "Buenos Aires",
            "provincia": "Buenos Aires",
            "pais": "Argentina"
          },
          "precio": {
            "monto": 3000,
            "moneda": "USD",
            "periodo": "mensual"
          },
          "tipo": "departamento",
          "ambientes": 2,
          "dormitorios": 1,
          "banos": 1,
          "superficie": {
            "total": 90,
            "cubierta": 85
          },
          "amueblado": true,
          "servicios": ["wifi", "agua", "electricidad", "gas"],
          "amenities": ["gimnasio", "pileta", "seguridad 24hs"],
          "ocupaciones": [],
          "fechasNoDisponibles": [],
          "contacto": {
            "nombre": "Federico Ramírez",
            "telefono": "+54 11 7777-8888",
            "email": "federico.ramirez@example.com"
          },
          "imagenes": [
            "https://ejemplo.com/loft-pm1.jpg",
            "https://ejemplo.com/loft-pm2.jpg"
          ],
          "fechaPublicacion": "2024-02-07T14:00:00Z",
          "descripcion": "Exclusivo loft con gran diseño y vistas espectaculares al río."
        }'


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/test/aws-backend-users.test.d.ts



/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/test/aws-backend-users.test.js

"use strict";
test('SQS Queue Created', () => {
});

/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/test/aws-backend-users.test.ts


test('SQS Queue Created', () => {

});


/**************/
/Users/matiaskochman/dev/personal/aws/aws-backend-users/tsconfig.json

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": [
      "es2020",
      "dom"
    ],
    "declaration": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": false,
    "inlineSourceMap": true,
    "inlineSources": true,
    "experimentalDecorators": true,
    "strictPropertyInitialization": false,
    "typeRoots": [
      "./node_modules/@types"
    ]
  },
  "exclude": [
    "node_modules",
    "cdk.out"
  ]
}


