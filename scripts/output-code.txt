// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/bin/aws-backend-users.js
#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cdk = require("aws-cdk-lib");
const aws_backend_users_stack_1 = require("../lib/aws-backend-users-stack");
require("dotenv/config");
const app = new cdk.App();
new aws_backend_users_stack_1.AwsBackendUsersStack(app, "AwsBackendUsersStack");

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/bin/aws-backend-users.ts
#!/usr/bin/env node
import * as cdk from "aws-cdk-lib";
import { AwsBackendUsersStack } from "../lib/aws-backend-users-stack";
import "dotenv/config";
const app = new cdk.App();
new AwsBackendUsersStack(app, "AwsBackendUsersStack");

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/cdk.json
{
  "app": "npx ts-node --prefer-ts-exts bin/aws-backend-users.ts",
  "watch": {
    "include": [
      "**"
    ],
    "exclude": [
      "README.md",
      "cdk*.json",
      "***.js",
      "tsconfig.json",
      "package*.json",
      "yarn.lock",
      "node_modules",
      "test"
    ]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": [
      "aws",
      "aws-cn"
    ],
    "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
    "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
    "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
    "@aws-cdk/aws-iam:minimizePolicies": true,
    "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
    "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
    "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
    "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
    "@aws-cdk/core:enablePartitionLiterals": true,
    "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
    "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
    "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
    "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
    "@aws-cdk/aws-route53-patters:useCertificate": true,
    "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
    "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
    "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
    "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
    "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
    "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
    "@aws-cdk/aws-redshift:columnId": true,
    "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
    "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
    "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
    "@aws-cdk/aws-kms:aliasNameRef": true,
    "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
    "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
    "@aws-cdk/aws-efs:denyAnonymousAccess": true,
    "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
    "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
    "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
    "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
    "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
    "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
    "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
    "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
    "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
    "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
    "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
    "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
    "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
    "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false,
    "@aws-cdk/aws-s3:keepNotificationInImportedBucket": false,
    "@aws-cdk/aws-ecs:enableImdsBlockingDeprecatedFeature": false,
    "@aws-cdk/aws-ecs:disableEcsImdsBlocking": true,
    "@aws-cdk/aws-ecs:reduceEc2FargateCloudWatchPermissions": true,
    "@aws-cdk/aws-dynamodb:resourcePolicyPerReplica": true,
    "@aws-cdk/aws-ec2:ec2SumTImeoutEnabled": true,
    "@aws-cdk/aws-appsync:appSyncGraphQLAPIScopeLambdaPermission": true,
    "@aws-cdk/aws-rds:setCorrectValueForDatabaseInstanceReadReplicaInstanceResourceId": true,
    "@aws-cdk/core:cfnIncludeRejectComplexResourceUpdateCreatePolicyIntrinsics": true,
    "@aws-cdk/aws-lambda-nodejs:sdkV3ExcludeSmithyPackages": true,
    "@aws-cdk/aws-stepfunctions-tasks:fixRunEcsTaskPolicy": true,
    "@aws-cdk/aws-ec2:bastionHostUseAmazonLinux2023ByDefault": true,
    "@aws-cdk/aws-route53-targets:userPoolDomainNameMethodWithoutCustomResource": true,
    "@aws-cdk/aws-elasticloadbalancingV2:albDualstackWithoutPublicIpv4SecurityGroupRulesDefault": true,
    "@aws-cdk/aws-iam:oidcRejectUnauthorizedConnections": true
  }
}

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/docker-compose.yml
# docker-compose.yml
version: "3.8"
services:
  localstack:
    image: localstack/localstack:latest
    container_name: localstack
    ports:
      - "4566:4566"
      - "4571:4571"
    environment:
      - SERVICES=lambda,apigateway,dynamodb,s3,ssm,cloudformation,iam
      - DEBUG=1
      - DATA_DIR=/tmp/localstack
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock"

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/addOccupation.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const idParam = event.pathParameters?.id;
        if (!idParam) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
            };
        }
        const id = Number(idParam);
        if (isNaN(id)) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El id debe ser un número" }),
            };
        }
        if (!event.body) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requiere el body de la petición" }),
            };
        }
        const { startDate, endDate } = JSON.parse(event.body);
        if (!startDate || !endDate) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requieren startDate y endDate" }),
            };
        }
        const command = new client_dynamodb_1.UpdateItemCommand({
            TableName: PROPERTIES_TABLE,
            Key: {
                id: { N: id.toString() },
            },
            UpdateExpression: "SET ocupaciones = list_append(if_not_exists(ocupaciones, :empty_list), :newOccupation)",
            ExpressionAttributeValues: {
                ":newOccupation": { L: [{ L: [{ S: startDate }, { S: endDate }] }] },
                ":empty_list": { L: [] },
            },
            ReturnValues: "ALL_NEW",
        });
        const response = await ddbClient.send(command);
        return {
            statusCode: 200,
            body: JSON.stringify({
                message: "Ocupación agregada exitosamente",
                property: response.Attributes,
            }),
        };
    }
    catch (error) {
        console.error("Error agregando la ocupación: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/addOccupation.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, UpdateItemCommand } from "@aws-sdk/client-dynamodb";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const idParam = event.pathParameters?.id;
    if (!idParam) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
      };
    }
    const id = Number(idParam);
    if (isNaN(id)) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El id debe ser un número" }),
      };
    }
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }
    const { startDate, endDate } = JSON.parse(event.body);
    if (!startDate || !endDate) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requieren startDate y endDate" }),
      };
    }
    const command = new UpdateItemCommand({
      TableName: PROPERTIES_TABLE,
      Key: {
        id: { N: id.toString() },
      },
      UpdateExpression:
        "SET ocupaciones = list_append(if_not_exists(ocupaciones, :empty_list), :newOccupation)",
      ExpressionAttributeValues: {
        ":newOccupation": { L: [{ L: [{ S: startDate }, { S: endDate }] }] },
        ":empty_list": { L: [] },
      },
      ReturnValues: "ALL_NEW",
    });
    const response = await ddbClient.send(command);
    return {
      statusCode: 200,
      body: JSON.stringify({
        message: "Ocupación agregada exitosamente",
        property: response.Attributes,
      }),
    };
  } catch (error) {
    console.error("Error agregando la ocupación: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/createProperty.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const util_dynamodb_1 = require("@aws-sdk/util-dynamodb");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
const handler = async (event) => {
    try {
        if (!event.body) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requiere el body de la petición" }),
            };
        }
        const data = JSON.parse(event.body);
        if (data.id === undefined || !data.titulo) {
            return {
                statusCode: 400,
                body: JSON.stringify({
                    message: "Se requieren los campos 'id' y 'titulo'",
                }),
            };
        }
        data.fechaPublicacion = new Date(data.fechaPublicacion).toISOString();
        const item = (0, util_dynamodb_1.marshall)(data, { removeUndefinedValues: true });
        const command = new client_dynamodb_1.PutItemCommand({
            TableName: PROPERTIES_TABLE,
            Item: item,
        });
        await ddbClient.send(command);
        return {
            statusCode: 201,
            body: JSON.stringify(data),
        };
    }
    catch (error) {
        console.error("Error creando la propiedad: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/createProperty.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, PutItemCommand } from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { Property } from "../../models/Property";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }
    const data: Property = JSON.parse(event.body);
    if (data.id === undefined || !data.titulo) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          message: "Se requieren los campos 'id' y 'titulo'",
        }),
      };
    }
    data.fechaPublicacion = new Date(data.fechaPublicacion).toISOString();
    const item = marshall(data, { removeUndefinedValues: true });
    const command = new PutItemCommand({
      TableName: PROPERTIES_TABLE,
      Item: item,
    });
    await ddbClient.send(command);
    return {
      statusCode: 201,
      body: JSON.stringify(data),
    };
  } catch (error) {
    console.error("Error creando la propiedad: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/deleteProperty.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const idParam = event.pathParameters?.id;
        if (!idParam) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
            };
        }
        const id = Number(idParam);
        if (isNaN(id)) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El id debe ser un número" }),
            };
        }
        const command = new client_dynamodb_1.DeleteItemCommand({
            TableName: PROPERTIES_TABLE,
            Key: {
                id: { N: id.toString() },
            },
        });
        await ddbClient.send(command);
        return {
            statusCode: 200,
            body: JSON.stringify({ message: "Propiedad eliminada exitosamente" }),
        };
    }
    catch (error) {
        console.error("Error eliminando la propiedad: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/deleteProperty.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, DeleteItemCommand } from "@aws-sdk/client-dynamodb";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const idParam = event.pathParameters?.id;
    if (!idParam) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
      };
    }
    const id = Number(idParam);
    if (isNaN(id)) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El id debe ser un número" }),
      };
    }
    const command = new DeleteItemCommand({
      TableName: PROPERTIES_TABLE,
      Key: {
        id: { N: id.toString() },
      },
    });
    await ddbClient.send(command);
    return {
      statusCode: 200,
      body: JSON.stringify({ message: "Propiedad eliminada exitosamente" }),
    };
  } catch (error) {
    console.error("Error eliminando la propiedad: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/getProperty.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const util_dynamodb_1 = require("@aws-sdk/util-dynamodb");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const idParam = event.pathParameters?.id;
        if (!idParam) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
            };
        }
        const id = Number(idParam);
        if (isNaN(id)) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El id debe ser un número" }),
            };
        }
        const command = new client_dynamodb_1.GetItemCommand({
            TableName: PROPERTIES_TABLE,
            Key: {
                id: { N: id.toString() },
            },
        });
        const response = await ddbClient.send(command);
        if (!response.Item) {
            return {
                statusCode: 404,
                body: JSON.stringify({ message: "Propiedad no encontrada" }),
            };
        }
        const property = (0, util_dynamodb_1.unmarshall)(response.Item);
        return {
            statusCode: 200,
            body: JSON.stringify(property),
        };
    }
    catch (error) {
        console.error("Error obteniendo la propiedad: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/getProperty.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, GetItemCommand } from "@aws-sdk/client-dynamodb";
import { unmarshall } from "@aws-sdk/util-dynamodb";
import { Property } from "../../models/Property";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const idParam = event.pathParameters?.id;
    if (!idParam) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
      };
    }
    const id = Number(idParam);
    if (isNaN(id)) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El id debe ser un número" }),
      };
    }
    const command = new GetItemCommand({
      TableName: PROPERTIES_TABLE,
      Key: {
        id: { N: id.toString() },
      },
    });
    const response = await ddbClient.send(command);
    if (!response.Item) {
      return {
        statusCode: 404,
        body: JSON.stringify({ message: "Propiedad no encontrada" }),
      };
    }
    const property = unmarshall(response.Item) as Property;
    return {
      statusCode: 200,
      body: JSON.stringify(property),
    };
  } catch (error) {
    console.error("Error obteniendo la propiedad: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/listProperties.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const util_dynamodb_1 = require("@aws-sdk/util-dynamodb");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const command = new client_dynamodb_1.ScanCommand({
            TableName: PROPERTIES_TABLE,
        });
        const response = await ddbClient.send(command);
        const properties = response.Items?.map((item) => (0, util_dynamodb_1.unmarshall)(item)) || [];
        return {
            statusCode: 200,
            body: JSON.stringify(properties),
        };
    }
    catch (error) {
        console.error("Error listando propiedades: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/listProperties.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, ScanCommand } from "@aws-sdk/client-dynamodb";
import { unmarshall } from "@aws-sdk/util-dynamodb";
import { Property } from "../../models/Property";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const command = new ScanCommand({
      TableName: PROPERTIES_TABLE,
    });
    const response = await ddbClient.send(command);
    const properties =
      response.Items?.map((item) => unmarshall(item) as Property) || [];
    return {
      statusCode: 200,
      body: JSON.stringify(properties),
    };
  } catch (error) {
    console.error("Error listando propiedades: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/updateProperty.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const util_dynamodb_1 = require("@aws-sdk/util-dynamodb");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const idParam = event.pathParameters?.id;
        if (!idParam) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
            };
        }
        const id = Number(idParam);
        if (isNaN(id)) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El id debe ser un número" }),
            };
        }
        if (!event.body) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requiere el body de la petición" }),
            };
        }
        const data = JSON.parse(event.body);
        if (data.id && Number(data.id) !== id) {
            return {
                statusCode: 400,
                body: JSON.stringify({
                    message: "El id del body debe coincidir con el id de la URL",
                }),
            };
        }
        data.id = id;
        data.fechaPublicacion = new Date(data.fechaPublicacion).toISOString();
        const item = (0, util_dynamodb_1.marshall)(data, { removeUndefinedValues: true });
        const command = new client_dynamodb_1.PutItemCommand({
            TableName: PROPERTIES_TABLE,
            Item: item,
        });
        await ddbClient.send(command);
        return {
            statusCode: 200,
            body: JSON.stringify(data),
        };
    }
    catch (error) {
        console.error("Error actualizando la propiedad: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/properties/updateProperty.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, PutItemCommand } from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { Property } from "../../models/Property";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const PROPERTIES_TABLE = process.env.PROPERTIES_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const idParam = event.pathParameters?.id;
    if (!idParam) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro id es obligatorio" }),
      };
    }
    const id = Number(idParam);
    if (isNaN(id)) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El id debe ser un número" }),
      };
    }
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }
    const data: Property = JSON.parse(event.body);
    if (data.id && Number(data.id) !== id) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          message: "El id del body debe coincidir con el id de la URL",
        }),
      };
    }
    data.id = id;
    data.fechaPublicacion = new Date(data.fechaPublicacion).toISOString();
    const item = marshall(data, { removeUndefinedValues: true });
    const command = new PutItemCommand({
      TableName: PROPERTIES_TABLE,
      Item: item,
    });
    await ddbClient.send(command);
    return {
      statusCode: 200,
      body: JSON.stringify(data),
    };
  } catch (error) {
    console.error("Error actualizando la propiedad: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/createUser.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const client_s3_1 = require("@aws-sdk/client-s3");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const s3Client = new client_s3_1.S3Client({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    forcePathStyle: true, 
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        if (!event.body) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requiere el body de la petición" }),
            };
        }
        const data = JSON.parse(event.body);
        const { userId, email, name } = data;
        if (!userId || !email || !name) {
            return {
                statusCode: 400,
                body: JSON.stringify({
                    message: "Faltan campos obligatorios: userId, email, name",
                }),
            };
        }
        const createdAt = new Date().toISOString();
        const command = new client_dynamodb_1.PutItemCommand({
            TableName: USERS_TABLE,
            Item: {
                userId: { S: userId },
                email: { S: email },
                name: { S: name },
                createdAt: { S: createdAt },
            },
        });
        await ddbClient.send(command);
        return {
            statusCode: 201,
            body: JSON.stringify({ userId, email, name, createdAt }),
        };
    }
    catch (error) {
        console.error("Error creando el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/createUser.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, PutItemCommand } from "@aws-sdk/client-dynamodb";
import { S3Client } from "@aws-sdk/client-s3";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const s3Client = new S3Client({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  forcePathStyle: true, 
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }
    const data = JSON.parse(event.body);
    const { userId, email, name } = data;
    if (!userId || !email || !name) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          message: "Faltan campos obligatorios: userId, email, name",
        }),
      };
    }
    const createdAt = new Date().toISOString();
    const command = new PutItemCommand({
      TableName: USERS_TABLE,
      Item: {
        userId: { S: userId },
        email: { S: email },
        name: { S: name },
        createdAt: { S: createdAt },
      },
    });
    await ddbClient.send(command);
    return {
      statusCode: 201,
      body: JSON.stringify({ userId, email, name, createdAt }),
    };
  } catch (error) {
    console.error("Error creando el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/deleteUser.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const client_s3_1 = require("@aws-sdk/client-s3");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const s3Client = new client_s3_1.S3Client({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    forcePathStyle: true, 
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const userId = event.pathParameters?.userId;
        if (!userId) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
            };
        }
        const command = new client_dynamodb_1.DeleteItemCommand({
            TableName: USERS_TABLE,
            Key: { userId: { S: userId } },
        });
        await ddbClient.send(command);
        return {
            statusCode: 200,
            body: JSON.stringify({ message: "Usuario eliminado exitosamente" }),
        };
    }
    catch (error) {
        console.error("Error eliminando el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/deleteUser.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, DeleteItemCommand } from "@aws-sdk/client-dynamodb";
import { S3Client } from "@aws-sdk/client-s3";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const s3Client = new S3Client({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  forcePathStyle: true, 
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const userId = event.pathParameters?.userId;
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
      };
    }
    const command = new DeleteItemCommand({
      TableName: USERS_TABLE,
      Key: { userId: { S: userId } },
    });
    await ddbClient.send(command);
    return {
      statusCode: 200,
      body: JSON.stringify({ message: "Usuario eliminado exitosamente" }),
    };
  } catch (error) {
    console.error("Error eliminando el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/generateUploadUrl.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_s3_1 = require("@aws-sdk/client-s3");
const s3_request_presigner_1 = require("@aws-sdk/s3-request-presigner");
const isLocal = process.env.USE_LOCALSTACK === "true";
const s3Client = new client_s3_1.S3Client({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    forcePathStyle: true, 
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const BUCKET_NAME = process.env.BUCKET_NAME || "";
const handler = async (event) => {
    try {
        const data = JSON.parse(event.body || "{}");
        const { fileName, fileType } = data;
        if (!fileName || !fileType) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requieren fileName y fileType" }),
            };
        }
        const command = new client_s3_1.PutObjectCommand({
            Bucket: BUCKET_NAME,
            Key: fileName,
            ContentType: fileType,
        });
        const signedUrl = await (0, s3_request_presigner_1.getSignedUrl)(s3Client, command, { expiresIn: 300 });
        return {
            statusCode: 200,
            body: JSON.stringify({ uploadUrl: signedUrl }),
        };
    }
    catch (error) {
        console.error("Error generando la URL firmada: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/generateUploadUrl.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
const isLocal = process.env.USE_LOCALSTACK === "true";
const s3Client = new S3Client({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  forcePathStyle: true, 
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const BUCKET_NAME = process.env.BUCKET_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const data = JSON.parse(event.body || "{}");
    const { fileName, fileType } = data;
    if (!fileName || !fileType) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requieren fileName y fileType" }),
      };
    }
    const command = new PutObjectCommand({
      Bucket: BUCKET_NAME,
      Key: fileName,
      ContentType: fileType,
    });
    const signedUrl = await getSignedUrl(s3Client, command, { expiresIn: 300 });
    return {
      statusCode: 200,
      body: JSON.stringify({ uploadUrl: signedUrl }),
    };
  } catch (error) {
    console.error("Error generando la URL firmada: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/getUser.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const userId = event.pathParameters?.userId;
        if (!userId) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
            };
        }
        const command = new client_dynamodb_1.GetItemCommand({
            TableName: USERS_TABLE,
            Key: { userId: { S: userId } },
        });
        const response = await ddbClient.send(command);
        if (!response.Item) {
            return {
                statusCode: 404,
                body: JSON.stringify({ message: "Usuario no encontrado" }),
            };
        }
        const user = {
            userId: response.Item.userId.S,
            email: response.Item.email.S,
            name: response.Item.name.S,
            createdAt: response.Item.createdAt.S,
        };
        return {
            statusCode: 200,
            body: JSON.stringify(user),
        };
    }
    catch (error) {
        console.error("Error obteniendo el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/getUser.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, GetItemCommand } from "@aws-sdk/client-dynamodb";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const userId = event.pathParameters?.userId;
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
      };
    }
    const command = new GetItemCommand({
      TableName: USERS_TABLE,
      Key: { userId: { S: userId } },
    });
    const response = await ddbClient.send(command);
    if (!response.Item) {
      return {
        statusCode: 404,
        body: JSON.stringify({ message: "Usuario no encontrado" }),
      };
    }
    const user = {
      userId: response.Item.userId.S,
      email: response.Item.email.S,
      name: response.Item.name.S,
      createdAt: response.Item.createdAt.S,
    };
    return {
      statusCode: 200,
      body: JSON.stringify(user),
    };
  } catch (error) {
    console.error("Error obteniendo el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/listUsers.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const command = new client_dynamodb_1.ScanCommand({ TableName: USERS_TABLE });
        const response = await ddbClient.send(command);
        const users = response.Items?.map((item) => ({
            userId: item.userId.S,
            email: item.email.S,
            name: item.name.S,
            createdAt: item.createdAt.S,
        })) || [];
        return {
            statusCode: 200,
            body: JSON.stringify(users),
        };
    }
    catch (error) {
        console.error("Error listando usuarios: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/listUsers.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, ScanCommand } from "@aws-sdk/client-dynamodb";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const command = new ScanCommand({ TableName: USERS_TABLE });
    const response = await ddbClient.send(command);
    const users =
      response.Items?.map((item) => ({
        userId: item.userId.S,
        email: item.email.S,
        name: item.name.S,
        createdAt: item.createdAt.S,
      })) || [];
    return {
      statusCode: 200,
      body: JSON.stringify(users),
    };
  } catch (error) {
    console.error("Error listando usuarios: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/updateUser.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new client_dynamodb_1.DynamoDBClient({
    endpoint: isLocal ? "http:
    region: "us-east-1",
    credentials: isLocal
        ? { accessKeyId: "test", secretAccessKey: "test" }
        : undefined,
});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
const handler = async (event) => {
    try {
        const userId = event.pathParameters?.userId;
        if (!userId) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
            };
        }
        if (!event.body) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Se requiere el body de la petición" }),
            };
        }
        const data = JSON.parse(event.body);
        const { name, email } = data;
        if (!name && !email) {
            return {
                statusCode: 400,
                body: JSON.stringify({ message: "Nada que actualizar" }),
            };
        }
        let updateExpression = "set";
        const ExpressionAttributeNames = {};
        const ExpressionAttributeValues = {};
        if (name) {
            updateExpression += " #name = :name,";
            ExpressionAttributeNames["#name"] = "name";
            ExpressionAttributeValues[":name"] = { S: name };
        }
        if (email) {
            updateExpression += " email = :email,";
            ExpressionAttributeValues[":email"] = { S: email };
        }
        updateExpression = updateExpression.slice(0, -1); 
        const command = new client_dynamodb_1.UpdateItemCommand({
            TableName: USERS_TABLE,
            Key: { userId: { S: userId } },
            UpdateExpression: updateExpression,
            ExpressionAttributeNames,
            ExpressionAttributeValues,
            ReturnValues: "ALL_NEW",
        });
        const response = await ddbClient.send(command);
        return {
            statusCode: 200,
            body: JSON.stringify(response.Attributes),
        };
    }
    catch (error) {
        console.error("Error actualizando el usuario: ", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ message: "Error interno del servidor" }),
        };
    }
};
exports.handler = handler;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lambda/users/updateUser.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { DynamoDBClient, UpdateItemCommand } from "@aws-sdk/client-dynamodb";
const isLocal = process.env.USE_LOCALSTACK === "true";
const ddbClient = new DynamoDBClient({
  endpoint: isLocal ? "http:
  region: "us-east-1",
  credentials: isLocal
    ? { accessKeyId: "test", secretAccessKey: "test" }
    : undefined,
});
const USERS_TABLE = process.env.USERS_TABLE_NAME || "";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const userId = event.pathParameters?.userId;
    if (!userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "El parámetro userId es obligatorio" }),
      };
    }
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Se requiere el body de la petición" }),
      };
    }
    const data = JSON.parse(event.body);
    const { name, email } = data;
    if (!name && !email) {
      return {
        statusCode: 400,
        body: JSON.stringify({ message: "Nada que actualizar" }),
      };
    }
    let updateExpression = "set";
    const ExpressionAttributeNames: Record<string, string> = {};
    const ExpressionAttributeValues: Record<string, any> = {};
    if (name) {
      updateExpression += " #name = :name,";
      ExpressionAttributeNames["#name"] = "name";
      ExpressionAttributeValues[":name"] = { S: name };
    }
    if (email) {
      updateExpression += " email = :email,";
      ExpressionAttributeValues[":email"] = { S: email };
    }
    updateExpression = updateExpression.slice(0, -1); 
    const command = new UpdateItemCommand({
      TableName: USERS_TABLE,
      Key: { userId: { S: userId } },
      UpdateExpression: updateExpression,
      ExpressionAttributeNames,
      ExpressionAttributeValues,
      ReturnValues: "ALL_NEW",
    });
    const response = await ddbClient.send(command);
    return {
      statusCode: 200,
      body: JSON.stringify(response.Attributes),
    };
  } catch (error) {
    console.error("Error actualizando el usuario: ", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno del servidor" }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lib/aws-backend-users-stack.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsBackendUsersStack = void 0;
const cdk = require("aws-cdk-lib");
const dynamodb = require("aws-cdk-lib/aws-dynamodb");
const s3 = require("aws-cdk-lib/aws-s3");
const lambda = require("aws-cdk-lib/aws-lambda");
const lambdaNodejs = require("aws-cdk-lib/aws-lambda-nodejs");
const apigateway = require("aws-cdk-lib/aws-apigateway");
const path = require("path");
class AwsBackendUsersStack extends cdk.Stack {
    constructor(scope, id, props) {
        super(scope, id, props);
        const usersTable = new dynamodb.Table(this, "UsersTable", {
            tableName: "Users",
            partitionKey: { name: "userId", type: dynamodb.AttributeType.STRING },
            billingMode: dynamodb.BillingMode.PROVISIONED,
            removalPolicy: cdk.RemovalPolicy.DESTROY,
        });
        usersTable.addGlobalSecondaryIndex({
            indexName: "EmailIndex",
            partitionKey: { name: "email", type: dynamodb.AttributeType.STRING },
            projectionType: dynamodb.ProjectionType.ALL,
        });
        const readScaling = usersTable.autoScaleReadCapacity({
            minCapacity: 5,
            maxCapacity: 50,
        });
        readScaling.scaleOnUtilization({
            targetUtilizationPercent: 70,
        });
        const writeScaling = usersTable.autoScaleWriteCapacity({
            minCapacity: 5,
            maxCapacity: 50,
        });
        writeScaling.scaleOnUtilization({
            targetUtilizationPercent: 70,
        });
        const userUploadsBucket = new s3.Bucket(this, "UserUploadsBucket", {
            bucketName: "user-uploads-cdk-v1",
            versioned: true,
            blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
            removalPolicy: cdk.RemovalPolicy.DESTROY,
            autoDeleteObjects: true,
        });
        const propertiesTable = new dynamodb.Table(this, "PropertiesTable", {
            tableName: "Properties",
            partitionKey: { name: "id", type: dynamodb.AttributeType.NUMBER },
            billingMode: dynamodb.BillingMode.PROVISIONED,
            removalPolicy: cdk.RemovalPolicy.DESTROY,
        });
        const propertiesReadScaling = propertiesTable.autoScaleReadCapacity({
            minCapacity: 5,
            maxCapacity: 50,
        });
        propertiesReadScaling.scaleOnUtilization({
            targetUtilizationPercent: 70,
        });
        const propertiesWriteScaling = propertiesTable.autoScaleWriteCapacity({
            minCapacity: 5,
            maxCapacity: 50,
        });
        propertiesWriteScaling.scaleOnUtilization({
            targetUtilizationPercent: 70,
        });
        const createUserLambda = new lambdaNodejs.NodejsFunction(this, "CreateUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/users/createUser.ts"),
            handler: "handler",
            environment: {
                USERS_TABLE_NAME: usersTable.tableName,
                BUCKET_NAME: userUploadsBucket.bucketName,
            },
        });
        usersTable.grantWriteData(createUserLambda);
        userUploadsBucket.grantPut(createUserLambda);
        const getUserLambda = new lambdaNodejs.NodejsFunction(this, "GetUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/users/getUser.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantReadData(getUserLambda);
        const listUsersLambda = new lambdaNodejs.NodejsFunction(this, "ListUsersFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/users/listUsers.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantReadData(listUsersLambda);
        const updateUserLambda = new lambdaNodejs.NodejsFunction(this, "UpdateUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/users/updateUser.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantReadWriteData(updateUserLambda);
        const deleteUserLambda = new lambdaNodejs.NodejsFunction(this, "DeleteUserFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/users/deleteUser.ts"),
            handler: "handler",
            environment: { USERS_TABLE_NAME: usersTable.tableName },
        });
        usersTable.grantWriteData(deleteUserLambda);
        const generateUploadUrlLambda = new lambdaNodejs.NodejsFunction(this, "GenerateUploadUrlFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/users/generateUploadUrl.ts"),
            handler: "handler",
            environment: { BUCKET_NAME: userUploadsBucket.bucketName },
        });
        userUploadsBucket.grantPut(generateUploadUrlLambda);
        userUploadsBucket.grantRead(generateUploadUrlLambda);
        const createPropertyLambda = new lambdaNodejs.NodejsFunction(this, "CreatePropertyFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/properties/createProperty.ts"),
            handler: "handler",
            environment: {
                PROPERTIES_TABLE_NAME: propertiesTable.tableName,
            },
        });
        propertiesTable.grantWriteData(createPropertyLambda);
        const getPropertyLambda = new lambdaNodejs.NodejsFunction(this, "GetPropertyFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/properties/getProperty.ts"),
            handler: "handler",
            environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
        });
        propertiesTable.grantReadData(getPropertyLambda);
        const listPropertiesLambda = new lambdaNodejs.NodejsFunction(this, "ListPropertiesFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/properties/listProperties.ts"),
            handler: "handler",
            environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
        });
        propertiesTable.grantReadData(listPropertiesLambda);
        const updatePropertyLambda = new lambdaNodejs.NodejsFunction(this, "UpdatePropertyFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/properties/updateProperty.ts"),
            handler: "handler",
            environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
        });
        propertiesTable.grantReadWriteData(updatePropertyLambda);
        const deletePropertyLambda = new lambdaNodejs.NodejsFunction(this, "DeletePropertyFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/properties/deleteProperty.ts"),
            handler: "handler",
            environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
        });
        propertiesTable.grantWriteData(deletePropertyLambda);
        const api = new apigateway.RestApi(this, "UsersAndPropertiesApi", {
            restApiName: "Users & Properties Service",
            defaultCorsPreflightOptions: {
                allowOrigins: apigateway.Cors.ALL_ORIGINS,
                allowMethods: apigateway.Cors.ALL_METHODS,
            },
        });
        const usersResource = api.root.addResource("users");
        usersResource.addMethod("POST", new apigateway.LambdaIntegration(createUserLambda));
        usersResource.addMethod("GET", new apigateway.LambdaIntegration(listUsersLambda));
        const userIdResource = usersResource.addResource("{userId}");
        userIdResource.addMethod("GET", new apigateway.LambdaIntegration(getUserLambda));
        userIdResource.addMethod("PUT", new apigateway.LambdaIntegration(updateUserLambda));
        userIdResource.addMethod("DELETE", new apigateway.LambdaIntegration(deleteUserLambda));
        const propertiesResource = api.root.addResource("properties");
        propertiesResource.addMethod("POST", new apigateway.LambdaIntegration(createPropertyLambda));
        propertiesResource.addMethod("GET", new apigateway.LambdaIntegration(listPropertiesLambda));
        const propertyIdResource = propertiesResource.addResource("{id}");
        propertyIdResource.addMethod("GET", new apigateway.LambdaIntegration(getPropertyLambda));
        propertyIdResource.addMethod("PUT", new apigateway.LambdaIntegration(updatePropertyLambda));
        propertyIdResource.addMethod("DELETE", new apigateway.LambdaIntegration(deletePropertyLambda));
        const addOccupationLambda = new lambdaNodejs.NodejsFunction(this, "AddOccupationFunction", {
            runtime: lambda.Runtime.NODEJS_18_X,
            entry: path.join(__dirname, "../lambda/properties/addOccupation.ts"),
            handler: "handler",
            environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
        });
        propertiesTable.grantWriteData(addOccupationLambda);
        const addOccupationResource = propertyIdResource.addResource("occupy");
        addOccupationResource.addMethod("POST", new apigateway.LambdaIntegration(addOccupationLambda));
    }
}
exports.AwsBackendUsersStack = AwsBackendUsersStack;

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/lib/aws-backend-users-stack.ts
import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
import * as s3 from "aws-cdk-lib/aws-s3";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as lambdaNodejs from "aws-cdk-lib/aws-lambda-nodejs";
import * as apigateway from "aws-cdk-lib/aws-apigateway";
import * as path from "path";
export class AwsBackendUsersStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);
    const usersTable = new dynamodb.Table(this, "UsersTable", {
      tableName: "Users",
      partitionKey: { name: "userId", type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PROVISIONED,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });
    usersTable.addGlobalSecondaryIndex({
      indexName: "EmailIndex",
      partitionKey: { name: "email", type: dynamodb.AttributeType.STRING },
      projectionType: dynamodb.ProjectionType.ALL,
    });
    const readScaling = usersTable.autoScaleReadCapacity({
      minCapacity: 5,
      maxCapacity: 50,
    });
    readScaling.scaleOnUtilization({
      targetUtilizationPercent: 70,
    });
    const writeScaling = usersTable.autoScaleWriteCapacity({
      minCapacity: 5,
      maxCapacity: 50,
    });
    writeScaling.scaleOnUtilization({
      targetUtilizationPercent: 70,
    });
    const userUploadsBucket = new s3.Bucket(this, "UserUploadsBucket", {
      bucketName: "user-uploads-cdk-v1",
      versioned: true,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      autoDeleteObjects: true,
    });
    const propertiesTable = new dynamodb.Table(this, "PropertiesTable", {
      tableName: "Properties",
      partitionKey: { name: "id", type: dynamodb.AttributeType.NUMBER },
      billingMode: dynamodb.BillingMode.PROVISIONED,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });
    const propertiesReadScaling = propertiesTable.autoScaleReadCapacity({
      minCapacity: 5,
      maxCapacity: 50,
    });
    propertiesReadScaling.scaleOnUtilization({
      targetUtilizationPercent: 70,
    });
    const propertiesWriteScaling = propertiesTable.autoScaleWriteCapacity({
      minCapacity: 5,
      maxCapacity: 50,
    });
    propertiesWriteScaling.scaleOnUtilization({
      targetUtilizationPercent: 70,
    });
    const createUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "CreateUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/createUser.ts"),
        handler: "handler",
        environment: {
          USERS_TABLE_NAME: usersTable.tableName,
          BUCKET_NAME: userUploadsBucket.bucketName,
        },
      }
    );
    usersTable.grantWriteData(createUserLambda);
    userUploadsBucket.grantPut(createUserLambda);
    const getUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "GetUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/getUser.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantReadData(getUserLambda);
    const listUsersLambda = new lambdaNodejs.NodejsFunction(
      this,
      "ListUsersFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/listUsers.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantReadData(listUsersLambda);
    const updateUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "UpdateUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/updateUser.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantReadWriteData(updateUserLambda);
    const deleteUserLambda = new lambdaNodejs.NodejsFunction(
      this,
      "DeleteUserFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/deleteUser.ts"),
        handler: "handler",
        environment: { USERS_TABLE_NAME: usersTable.tableName },
      }
    );
    usersTable.grantWriteData(deleteUserLambda);
    const generateUploadUrlLambda = new lambdaNodejs.NodejsFunction(
      this,
      "GenerateUploadUrlFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/users/generateUploadUrl.ts"),
        handler: "handler",
        environment: { BUCKET_NAME: userUploadsBucket.bucketName },
      }
    );
    userUploadsBucket.grantPut(generateUploadUrlLambda);
    userUploadsBucket.grantRead(generateUploadUrlLambda);
    const createPropertyLambda = new lambdaNodejs.NodejsFunction(
      this,
      "CreatePropertyFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/createProperty.ts"),
        handler: "handler",
        environment: {
          PROPERTIES_TABLE_NAME: propertiesTable.tableName,
        },
      }
    );
    propertiesTable.grantWriteData(createPropertyLambda);
    const getPropertyLambda = new lambdaNodejs.NodejsFunction(
      this,
      "GetPropertyFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/getProperty.ts"),
        handler: "handler",
        environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
      }
    );
    propertiesTable.grantReadData(getPropertyLambda);
    const listPropertiesLambda = new lambdaNodejs.NodejsFunction(
      this,
      "ListPropertiesFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/listProperties.ts"),
        handler: "handler",
        environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
      }
    );
    propertiesTable.grantReadData(listPropertiesLambda);
    const updatePropertyLambda = new lambdaNodejs.NodejsFunction(
      this,
      "UpdatePropertyFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/updateProperty.ts"),
        handler: "handler",
        environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
      }
    );
    propertiesTable.grantReadWriteData(updatePropertyLambda);
    const deletePropertyLambda = new lambdaNodejs.NodejsFunction(
      this,
      "DeletePropertyFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/deleteProperty.ts"),
        handler: "handler",
        environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
      }
    );
    propertiesTable.grantWriteData(deletePropertyLambda);
    const api = new apigateway.RestApi(this, "UsersAndPropertiesApi", {
      restApiName: "Users & Properties Service",
      defaultCorsPreflightOptions: {
        allowOrigins: apigateway.Cors.ALL_ORIGINS,
        allowMethods: apigateway.Cors.ALL_METHODS,
      },
    });
    const usersResource = api.root.addResource("users");
    usersResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(createUserLambda)
    );
    usersResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(listUsersLambda)
    );
    const userIdResource = usersResource.addResource("{userId}");
    userIdResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(getUserLambda)
    );
    userIdResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(updateUserLambda)
    );
    userIdResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(deleteUserLambda)
    );
    const propertiesResource = api.root.addResource("properties");
    propertiesResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(createPropertyLambda)
    );
    propertiesResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(listPropertiesLambda)
    );
    const propertyIdResource = propertiesResource.addResource("{id}");
    propertyIdResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(getPropertyLambda)
    );
    propertyIdResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(updatePropertyLambda)
    );
    propertyIdResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(deletePropertyLambda)
    );
    const addOccupationLambda = new lambdaNodejs.NodejsFunction(
      this,
      "AddOccupationFunction",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../lambda/properties/addOccupation.ts"),
        handler: "handler",
        environment: { PROPERTIES_TABLE_NAME: propertiesTable.tableName },
      }
    );
    propertiesTable.grantWriteData(addOccupationLambda);
    const addOccupationResource = propertyIdResource.addResource("occupy");
    addOccupationResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(addOccupationLambda)
    );
  }
}

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/models/Property.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/models/Property.ts
export interface Property {
  id: number;
  titulo: string;
  ubicacion: {
    direccion: string;
    ciudad: string;
    provincia: string;
    pais: string;
  };
  precio: {
    monto: number;
    moneda: "USD" | "ARS" | "EUR"; 
    periodo: "mensual" | "anual" | "semanal"; 
  };
  tipo: "departamento" | "casa" | "ph" | "terreno"; 
  ambientes: number;
  dormitorios: number;
  banos: number;
  superficie: {
    total: number; 
    cubierta: number; 
  };
  amueblado: boolean;
  servicios: string[];
  amenities: string[];
  ocupaciones: [string, string][]; 
  fechasNoDisponibles: string[]; 
  contacto: {
    nombre: string;
    telefono: string;
    email: string;
  };
  imagenes: string[];
  fechaPublicacion: string; 
  descripcion: string;
}

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/package.json
{
  "name": "aws-backend-users",
  "version": "0.1.0",
  "bin": {
    "aws-backend-users": "bin/aws-backend-users.js"
  },
  "scripts": {
    "build": "tsc",
    "watch": "tsc -w",
    "test": "jest",
    "cdk": "cdk",
    "start:local": "USE_LOCALSTACK=true node bin/aws-backend-users.js",
    "localstack:init": "./scripts/init-localstack.sh",
    "localstack:up": "docker-compose up -d",
    "localstack:down": "docker-compose down"
  },
  "devDependencies": {
    "@types/aws-lambda": "^8.10.147",
    "@types/jest": "^29.5.14",
    "@types/node": "22.7.9",
    "aws-cdk": "2.177.0",
    "jest": "^29.7.0",
    "source-map-support": "^0.5.21",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "~5.6.3"
  },
  "dependencies": {
    "@aws-cdk/core": "^1.203.0",
    "@aws-sdk/client-dynamodb": "^3.738.0",
    "@aws-sdk/client-s3": "^3.740.0",
    "@aws-sdk/s3-request-presigner": "^3.740.0",
    "@aws-sdk/util-dynamodb": "^3.738.0",
    "aws-cdk-lib": "^2.177.0",
    "constructs": "^10.4.2",
    "dotenv": "^16.4.7"
  }
}

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/scripts/curls.sh
API_URL="https:
curl -X POST "$API_URL" \
     -H "Content-Type: application/json" \
     -d '{
          "id": 1,
          "titulo": "Departamento en Palermo, Buenos Aires",
          "ubicacion": {
            "direccion": "Av. Santa Fe 3400",
            "ciudad": "Buenos Aires",
            "provincia": "Buenos Aires",
            "pais": "Argentina"
          },
          "precio": {
            "monto": 800,
            "moneda": "USD",
            "periodo": "mensual"
          },
          "tipo": "departamento",
          "ambientes": 3,
          "dormitorios": 2,
          "banos": 1,
          "superficie": {
            "total": 80,
            "cubierta": 70
          },
          "amueblado": true,
          "servicios": ["wifi", "agua", "electricidad", "gas"],
          "amenities": ["pileta", "gimnasio", "terraza", "seguridad 24hs"],
          "ocupaciones": [["01-01-2025", "15-01-2025"]],
          "fechasNoDisponibles": ["25-12-2024"],
          "contacto": {
            "nombre": "Juan Pérez",
            "telefono": "+54 11 1234-5678",
            "email": "juanperez@example.com"
          },
          "imagenes": [
            "https:
            "https:
          ],
          "fechaPublicacion": "2024-02-03T12:00:00Z",
          "descripcion": "Departamento moderno en el corazón de Palermo, ideal para familias o parejas."
        }'
curl -X POST "$API_URL" \
     -H "Content-Type: application/json" \
     -d '{
          "id": 2,
          "titulo": "Casa en Nordelta con jardín y pileta",
          "ubicacion": {
            "direccion": "Calle Los Álamos 123",
            "ciudad": "Tigre",
            "provincia": "Buenos Aires",
            "pais": "Argentina"
          },
          "precio": {
            "monto": 2500,
            "moneda": "USD",
            "periodo": "mensual"
          },
          "tipo": "casa",
          "ambientes": 5,
          "dormitorios": 4,
          "banos": 3,
          "superficie": {
            "total": 300,
            "cubierta": 250
          },
          "amueblado": false,
          "servicios": ["wifi", "agua", "electricidad", "gas", "seguridad"],
          "amenities": ["pileta", "quincho", "cochera doble"],
          "ocupaciones": [],
          "fechasNoDisponibles": ["01-05-2025"],
          "contacto": {
            "nombre": "María Rodríguez",
            "telefono": "+54 11 9876-5432",
            "email": "maria.rodriguez@example.com"
          },
          "imagenes": [
            "https:
            "https:
          ],
          "fechaPublicacion": "2024-02-05T15:00:00Z",
          "descripcion": "Hermosa casa en barrio privado, con vista al lago y excelente seguridad."
        }'
curl -X POST "$API_URL" \
     -H "Content-Type: application/json" \
     -d '{
          "id": 3,
          "titulo": "PH en San Telmo con terraza propia",
          "ubicacion": {
            "direccion": "Defensa 750",
            "ciudad": "Buenos Aires",
            "provincia": "Buenos Aires",
            "pais": "Argentina"
          },
          "precio": {
            "monto": 1200,
            "moneda": "USD",
            "periodo": "mensual"
          },
          "tipo": "ph",
          "ambientes": 4,
          "dormitorios": 2,
          "banos": 2,
          "superficie": {
            "total": 150,
            "cubierta": 100
          },
          "amueblado": true,
          "servicios": ["wifi", "agua", "electricidad", "gas"],
          "amenities": ["terraza", "parrilla"],
          "ocupaciones": [["05-06-2025", "20-06-2025"]],
          "fechasNoDisponibles": [],
          "contacto": {
            "nombre": "Carlos López",
            "telefono": "+54 11 3333-5555",
            "email": "carlos.lopez@example.com"
          },
          "imagenes": [
            "https:
            "https:
          ],
          "fechaPublicacion": "2024-02-06T18:00:00Z",
          "descripcion": "PH con detalles únicos, techos altos y una increíble terraza en el corazón de San Telmo."
        }'
curl -X POST "$API_URL" \
     -H "Content-Type: application/json" \
     -d '{
          "id": 4,
          "titulo": "Terreno en Bariloche con vista al lago",
          "ubicacion": {
            "direccion": "Ruta 40 km 2040",
            "ciudad": "San Carlos de Bariloche",
            "provincia": "Río Negro",
            "pais": "Argentina"
          },
          "precio": {
            "monto": 100000,
            "moneda": "USD",
            "periodo": "único"
          },
          "tipo": "terreno",
          "ambientes": 0,
          "dormitorios": 0,
          "banos": 0,
          "superficie": {
            "total": 5000,
            "cubierta": 0
          },
          "amueblado": false,
          "servicios": ["electricidad", "agua"],
          "amenities": [],
          "ocupaciones": [],
          "fechasNoDisponibles": [],
          "contacto": {
            "nombre": "Luciana Gómez",
            "telefono": "+54 294 456-7890",
            "email": "luciana.gomez@example.com"
          },
          "imagenes": [
            "https:
            "https:
          ],
          "fechaPublicacion": "2024-02-07T09:30:00Z",
          "descripcion": "Terreno amplio con vista panorámica al lago Nahuel Huapi, ideal para construir cabañas."
        }'
curl -X POST "$API_URL" \
     -H "Content-Type: application/json" \
     -d '{
          "id": 5,
          "titulo": "Loft en Puerto Madero con vista al río",
          "ubicacion": {
            "direccion": "Av. Alicia Moreau de Justo 2000",
            "ciudad": "Buenos Aires",
            "provincia": "Buenos Aires",
            "pais": "Argentina"
          },
          "precio": {
            "monto": 3000,
            "moneda": "USD",
            "periodo": "mensual"
          },
          "tipo": "departamento",
          "ambientes": 2,
          "dormitorios": 1,
          "banos": 1,
          "superficie": {
            "total": 90,
            "cubierta": 85
          },
          "amueblado": true,
          "servicios": ["wifi", "agua", "electricidad", "gas"],
          "amenities": ["gimnasio", "pileta", "seguridad 24hs"],
          "ocupaciones": [],
          "fechasNoDisponibles": [],
          "contacto": {
            "nombre": "Federico Ramírez",
            "telefono": "+54 11 7777-8888",
            "email": "federico.ramirez@example.com"
          },
          "imagenes": [
            "https:
            "https:
          ],
          "fechaPublicacion": "2024-02-07T14:00:00Z",
          "descripcion": "Exclusivo loft con gran diseño y vistas espectaculares al río."
        }'
curl -X POST "$API_URL/1/occupy" \
     -H "Content-Type: application/json" \
     -d '{
          "startDate": "10-02-2025",
          "endDate": "20-02-2025"
        }'
curl -X GET "$API_URL/1"

/**********/

// File: /Users/matiaskochman/dev/personal/aws/aws-backend-users/scripts/init-localstack.sh
#!/bin/bash
echo "Iniciando LocalStack..."
# Función para verificar si una tabla de DynamoDB existe
table_exists() {
  aws dynamodb describe-table --table-name "$1" --endpoint-url http:
}
# Crear la tabla de usuarios si no existe
if ! table_exists "Users"; then
  aws dynamodb create-table --table-name Users \
    --attribute-definitions AttributeName=userId,AttributeType=S \
    --key-schema AttributeName=userId,KeyType=HASH \
    --billing-mode PAY_PER_REQUEST \
    --endpoint-url http:
  echo "Tabla 'Users' creada."
else
  echo "Tabla 'Users' ya existe."
fi
# Crear la tabla de propiedades si no existe
if ! table_exists "Properties"; then
  aws dynamodb create-table --table-name Properties \
    --attribute-definitions AttributeName=id,AttributeType=N \
    --key-schema AttributeName=id,KeyType=HASH \
    --billing-mode PAY_PER_REQUEST \
    --endpoint-url http:
  echo "Tabla 'Properties' creada."
else
  echo "Tabla 'Properties' ya existe."
fi
# Verificar si el bucket S3 ya existe antes de crearlo
if ! aws s3 ls --endpoint-url http:
  aws s3 mb s3:
  echo "Bucket 'user-uploads-cdk-v1' creado."
else
  echo "Bucket 'user-uploads-cdk-v1' ya existe."
fi
echo "LocalStack inicializado!"

/**********/

